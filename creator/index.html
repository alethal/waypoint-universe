<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Spatial Waypoint Editor</title>
  <script src="../standalone-export.js"></script>
  <link rel="stylesheet" href="../gallery-editor.css">
  <!-- ImgBB Uploader (from shared folder - works standalone after deployment) -->
  <link rel="stylesheet" href="../shared/imgbb-uploader.css">
  <script src="../shared/imgbb-uploader.js"></script>
  <!-- ACCID Universal Image Picker -->
  <script src="../shared/accid-image-picker.js"></script>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, sans-serif;
      margin: 0;
      padding: 0;
    }

    /* Vertical Tabs (Right Side) - Always visible on creator page */
    .preview-tabs {
      position: fixed;
      right: 0;
      top: 140px;
      z-index: 1000;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .preview-tab {
      writing-mode: vertical-rl;
      text-orientation: mixed;
      padding: 20px 12px;
      background: #343a40;
      color: white;
      border: none;
      border-left: 3px solid #0d6efd;
      /* Blue edge to make it more visible */
      cursor: pointer;
      font-size: 14px;
      font-weight: 600;
      transition: all 0.3s ease;
      border-radius: 8px 0 0 8px;
      letter-spacing: 2px;
      text-decoration: none;
      display: block;
      box-shadow: -2px 0 8px rgba(0, 0, 0, 0.3);
      /* Shadow for depth */
    }

    .preview-tab:hover {
      background: #495057;
      padding-left: 16px;
    }

    .preview-tab.active {
      background: #0d6efd;
      padding-left: 16px;
    }

    /* Layout and Perspectives tabs - same style as preview */
    .settings-tabs {
      position: fixed;
      right: 0;
      top: 220px;
      z-index: 1000;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .settings-tab {
      writing-mode: vertical-rl;
      text-orientation: mixed;
      padding: 20px 12px;
      background: #343a40;
      color: white;
      border: none;
      border-left: 3px solid #667eea;
      cursor: pointer;
      font-size: 14px;
      font-weight: 600;
      transition: all 0.3s ease;
      border-radius: 8px 0 0 8px;
      letter-spacing: 2px;
      text-decoration: none;
      display: block;
      box-shadow: -2px 0 8px rgba(0, 0, 0, 0.3);
    }

    .settings-tab:hover {
      background: #495057;
      padding-left: 16px;
    }

    .settings-tab.active {
      background: #667eea;
      padding-left: 16px;
    }

    /* Pulsing animation for Save button */
    @keyframes pulse-save {

      0%,
      100% {
        box-shadow: 0 0 0 0 rgba(40, 167, 69, 0.7);
        transform: scale(1);
      }

      50% {
        box-shadow: 0 0 0 8px rgba(40, 167, 69, 0);
        transform: scale(1.05);
      }
    }

    #accid-save {
      animation: pulse-save 3s ease-in-out infinite;
    }

    /* Editor content - just small right margin for collapsed tabs */
    .editor-content {
      margin-right: 30px;
      /* Small space for collapsed tab tips */
    }

    body.edit-mode {
      padding-top: 0;
      margin-top: 80px;
    }

    .edit-mode #export-standalone {
      display: none !important;
    }

    #countryStatus {
      text-transform: capitalize;
      color: #fff;
      margin: 0 0 5px 0;
    }

    /* Old template nav removed - using vertical slide-out tabs instead */
    .template-nav a {
      margin-left: 10px;
      padding: 8px 16px;
      background: #007bff;
      color: #fff;
      text-decoration: none;
      border-radius: 4px;
    }

    .edit-mode .template-nav {
      margin-top: 60px;
    }

    /* Creator Bridge Panel */
    .creator-bridge {
      position: fixed;
      right: 0;
      z-index: 900;
      background: rgba(0, 0, 0, 0.85);
      backdrop-filter: blur(10px);
      border-radius: 12px 0 0 12px;
      border: 1px solid rgba(102, 126, 234, 0.4);
      border-right: none;
      box-shadow: -4px 0 16px rgba(0, 0, 0, 0.5);
      transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      max-height: 80vh;
      overflow-y: auto;
    }

    /* Layout Bridge - positioned higher */
    #layoutBridge {
      top: 25%;
      transform: translateY(-50%);
    }

    /* Perspectives Bridge - positioned lower */
    #perspectivesBridge {
      top: 60%;
      transform: translateY(-50%);
    }

    .creator-bridge.collapsed {
      transform: translateY(-50%) translateX(calc(100% - 45px));
      cursor: pointer;
    }

    .creator-bridge .bridge-tab-toggle {
      position: absolute;
      left: -45px;
      top: 50%;
      transform: translateY(-50%);
      width: 45px;
      height: 70px;
      background: rgba(0, 0, 0, 0.85);
      border: 1px solid rgba(102, 126, 234, 0.4);
      border-right: none;
      border-radius: 12px 0 0 12px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      color: #667eea;
      font-size: 1.5em;
      transition: all 0.3s ease;
    }

    .creator-bridge .bridge-tab-toggle:hover {
      background: rgba(102, 126, 234, 0.2);
      color: #8899ff;
      transform: translateY(-50%) scale(1.05);
    }

    .creator-bridge .bridge-content {
      padding: 1.5em;
      width: 320px;
      position: relative;
    }

    .creator-bridge .bridge-close {
      position: absolute;
      top: 0.75em;
      right: 0.75em;
      background: rgba(102, 126, 234, 0.2);
      border: 1px solid rgba(102, 126, 234, 0.4);
      color: white;
      width: 28px;
      height: 28px;
      border-radius: 6px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.2em;
      transition: all 0.2s ease;
      z-index: 10;
    }

    .creator-bridge .bridge-close:hover {
      background: rgba(102, 126, 234, 0.4);
      transform: scale(1.1);
    }

    .creator-bridge .bridge-section {
      margin-bottom: 1.5em;
      padding-bottom: 1.5em;
      border-bottom: 1px solid rgba(102, 126, 234, 0.2);
    }

    .creator-bridge .bridge-section:last-child {
      border-bottom: none;
      margin-bottom: 0;
    }

    .creator-bridge .bridge-section h4 {
      margin: 0 0 0.75em 0;
      color: #8899ff;
      font-size: 0.9em;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    /* Bridge Perspectives List - Dark theme overrides */
    .creator-bridge .perspective-item-setup {
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    .creator-bridge .perspective-name-input,
    .creator-bridge .perspective-desc-input {
      background: rgba(255, 255, 255, 0.15);
      border: 1px solid rgba(255, 255, 255, 0.2);
      color: white;
    }

    .creator-bridge .perspective-name-input::placeholder,
    .creator-bridge .perspective-desc-input::placeholder {
      color: rgba(255, 255, 255, 0.5);
    }

    .creator-bridge .perspective-color-picker {
      border-color: rgba(255, 255, 255, 0.3);
    }

    .creator-bridge .remove-perspective-btn {
      background: rgba(220, 53, 69, 0.6);
      padding: 2px 6px;
      font-size: 11px;
    }

    .creator-bridge .remove-perspective-btn:hover {
      background: rgba(220, 53, 69, 0.8);
    }

    .creator-bridge .add-perspective-btn:hover {
      background: rgba(102, 126, 234, 0.5);
    }

    /* Country Selection Styles */
    .trip-settings {
      top: 49px;
      left: 40px;
      margin: 0;
      padding: 20px 20px;
      background: rgba(34, 34, 34, .46);
      position: fixed;
      width: 100%;
      box-sizing: border-box;
      max-width: 33vw;
      border-bottom-right-radius: 16px;
      border-bottom-left-radius: 17px;
      z-index: 1200;
    }

    .trip-settings h3 {
      margin: 0 0 15px 0;
      color: #FFFFFF;
      font-size: 18px;
    }

    .country-selector {
      display: block;
      margin-bottom: 10px;
    }

    .country-selector select {
      padding: 8px 12px;
      border: 1px solid #ced4da;
      border-radius: 6px;
      font-size: 14px;
    }



    /* Universal Grid System Styles */
    .location-editor-btn {
      background: #28a745;
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      margin-left: 10px;
    }

    .location-editor-btn:hover {
      background: #218838;
    }

    .grid-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0, 0, 0, 0.9);
      z-index: 9999;
      display: none;
      align-items: center;
      justify-content: center;
    }

    .grid-editor {
      background: white;
      border-radius: 12px;
      padding: 20px;
      width: 100%;
      height: 100%;
      max-width: 90vw;
      max-height: 90vh;
      overflow: auto;
      position: relative;
    }

    .grid-editor h2 {
      margin: 0 0 20px 0;
      color: #333;
    }

    .map-container {
      position: relative;
      display: flex;
      justify-content: center;
      align-items: center;
      border: 0px solid #333;
      border-radius: 8px;
      overflow: hidden;
      background: radial-gradient(circle at center, #cccccc 0%, #ffffff 40%);
      width: 100%;
      max-width: 800px;
      aspect-ratio: 16 / 9;
      margin: 0 auto;
    }

    .universal-grid {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      cursor: crosshair;
    }

    .location-dot {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 12px;
      height: 12px;
      background: #ff6b00;
      border: 2px solid white;
      border-radius: 50%;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
      pointer-events: none;
    }

    .grid-controls {
      margin-top: 20px;
      display: flex;
      gap: 10px;
      align-items: center;
    }

    .grid-controls button {
      padding: 8px 16px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }

    .save-locations {
      background: #28a745;
      color: white;
    }

    .cancel-locations {
      background: #6c757d;
      color: white;
      position: absolute;
      right: 20px;
      top: 20px;
    }

    .clear-locations {
      background: #dc3545;
      color: white;
    }

    .location-list {
      margin-top: 15px;
      max-height: 150px;
      overflow-y: auto;
      border: 1px solid #ddd;
      border-radius: 4px;
      padding: 10px;
    }

    .location-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 5px 0;
      border-bottom: 1px solid #eee;
    }

    .location-item:last-child {
      border-bottom: none;
    }

    .delete-location {
      background: #dc3545;
      color: white;
      border: none;
      padding: 2px 6px;
      border-radius: 3px;
      cursor: pointer;
      font-size: 12px;
    }

    .preview-link {
      text-decoration: underline;
      overflow-wrap: break-word;
    }

    .photo-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      /* Changed from 4 to 2 for larger photos */
      gap: 24px;
      /* Increased gap for better spacing */
      max-width: 1400px;
      /* Increased max-width for larger layout */
      margin: 20px auto 0;
      padding: 0 20px;
    }

    .card {
      border-radius: 12px;
      overflow: visible;
      /* Changed from hidden to allow waypoint popups to extend beyond card */
      box-shadow: 0 4px 12px rgba(0, 0, 0, .15);
      background: #fff;
      display: flex;
      flex-direction: column;
    }

    .card {
      position: relative;
    }

    /* Keep the card image container clipped */
    .card .photo-container {
      position: relative;
      overflow: hidden;
      border-radius: 12px 12px 0 0;
      min-height: 75px;
    }

    .card img {
      width: 100%;
      display: block;
    }

    /* Photo container for waypoints - removed duplicate, handled above */

    /* Replace Photo Icon - Universal pattern for all photos */
    .replace-photo-icon {
      position: absolute;
      top: 12px;
      right: -20px;
      width: 40px;
      height: 40px;
      background: rgb(255 152 0 / 65%);
      border-top-left-radius: 50px;
      border-bottom-left-radius: 50px;
      margin: 0 20px 0 0px;
      display: flex;
      align-items: center;
      justify-content: flex-start;
      font-size: 20px;
      cursor: pointer;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
      transition: all 0.2s ease;
      z-index: 100;
      border: 2px solid white;
      padding: 0 0 0 20px;
    }

    .replace-photo-icon:hover {
      transform: scale(1.15);
      background: rgba(255, 152, 0, 1);
      box-shadow: 0 4px 12px rgba(255, 152, 0, 0.5);
    }

    /* Waypoint dots on card photos */
    .card-waypoint-dot {
      position: absolute;
      width: 28px;
      height: 28px;
      border-radius: 50%;
      background: rgba(255, 20, 102, 0.9);
      border: 2px solid white;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.4);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 16px;
      cursor: pointer;
      transform: translate(-50%, -50%);
      transition: all 0.2s ease;
      z-index: 50;
    }

    .card-waypoint-dot:hover {
      transform: translate(-50%, -50%) scale(1.2);
      box-shadow: 0 4px 12px rgba(255, 20, 102, 0.6);
      z-index: 60;
    }

    /* Small waypoint popup on card - horizontal layout, single row */
    .waypoint-card-popup {
      position: absolute;
      /* Scrolls with page */
      background: rgba(0, 0, 0, 0.95);
      color: white;
      padding: 10px 16px;
      border-radius: 8px;
      width: auto;
      max-width: 600px;
      min-width: 400px;
      box-shadow: 0 4px 16px rgba(0, 0, 0, 0.5);
      z-index: 10000;
      /* Very high to be above everything */
      display: none;
    }

    /* Make form elements display inline for horizontal layout */
    .waypoint-card-popup label {
      display: inline-block;
      margin-right: 6px;
      margin-left: 12px;
      font-size: 11px;
    }

    .waypoint-card-popup label:first-child {
      margin-left: 0;
    }

    .waypoint-card-popup input,
    .waypoint-card-popup select {
      display: inline-block;
      width: auto;
      min-width: 100px;
      vertical-align: middle;
    }

    .waypoint-card-popup>div {
      display: inline-block;
    }

    .waypoint-card-popup.active {
      display: block;
    }

    .waypoint-card-popup label {
      display: block;
      font-size: 11px;
      color: #aaa;
      margin-bottom: 4px;
      margin-top: 8px;
    }

    .waypoint-card-popup label:first-child {
      margin-top: 0;
    }

    .waypoint-card-popup input,
    .waypoint-card-popup select {
      width: 100%;
      padding: 6px 8px;
      background: #2a2a2a;
      border: 1px solid #444;
      color: white;
      border-radius: 4px;
      font-size: 13px;
    }

    .waypoint-card-popup .remove-waypoint-btn {
      margin-top: 8px;
      padding: 6px 12px;
      background: #dc3545;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
      width: 100%;
      position: absolute;
      top: -15px;
      right: -25px;
      z-index: 100;
      max-width: 105px;
    }


    .save-waypoint-btn {
      width: 100%;
      padding: 10px;
      margin: 4px 0 !important;
      ;
    }

    .waypoint-card-popup .remove-waypoint-btn:hover {
      background: #c82333;
    }

    .card .info {
      flex: 1;
    }

    .info {
      padding: 12px;
    }

    .caption {
      font-weight: 600;
      margin-bottom: 4px;
    }

    .location {
      color: #666;
      font-size: 14px;
    }

    .edit-fields {
      display: none;
      margin-top: 12px;
      padding: 12px;
      background: #f8f9fa;
      border-radius: 8px;
      border: 1px solid #e9ecef;
      font-size: 13px;
      color: #333;
    }

    .edit-fields label {
      display: block;
      margin: 12px 0 4px;
      font-weight: 600;
      color: #333;
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .edit-fields input,
    .edit-fields textarea,
    .edit-fields select {
      width: 100%;
      padding: 8px 10px;
      font-size: 13px;
      border: 1px solid #ced4da;
      border-radius: 6px;
      background: #d1d1d1;
      transition: border-color 0.15s ease-in-out, box-shadow 0.15s ease-in-out;
    }

    .edit-fields input:focus,
    .edit-fields textarea:focus,
    .edit-fields select:focus {
      outline: 0;
      background: #fff;
      border-color: #80bdff;
      box-shadow: 0 0 0 0.2rem rgba(0, 123, 255, 0.25);
    }

    .edit-fields textarea {
      resize: vertical;
      min-height: 60px;
    }

    .edit-fields .half {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
      margin-top: 12px;
    }

    .edit-fields .half label {
      margin-top: 0;
    }

    .edit-fields input[type="checkbox"] {
      width: auto;
      margin-top: 4px;
    }

    /* Sub-location section styling */
    .sub-location-section {
      margin: 12px 0;
      padding: 0;
      background: #fff;
      border: 1px solid #dee2e6;
      border-radius: 6px;
    }

    .sub-location-instructions {
      font-size: 11px;
      color: #6c757d;
      margin-bottom: 8px;
      line-height: 1.4;
    }

    .sub-location-step {
      margin-bottom: 6px;
    }

    .sub-location-step:last-child {
      margin-bottom: 0;
    }

    /* Improved location map button */
    .location-map-btn {
      background: #17a2b8;
      color: white;
      border: none;
      padding: 6px 12px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 11px;
      font-weight: 500;
      margin: 4px 0;
      transition: background-color 0.15s ease-in-out;
    }

    .location-map-btn:hover {
      background: #138496;
    }

    /* Form field grouping */
    .field-group {
      margin-bottom: 8px;
    }

    .field-group:last-child {
      margin-bottom: 0;
    }


    /* Trip Settings Overlay Styles */
    .trip-overlay {
      display: none;
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, .5);
      z-index: 9000;
    }

    .trip-close-btn {
      position: absolute;
      top: 70px;
      left: 31vw;
      background: #e44;
      border: 0;
      color: #fff;
      border-radius: 5px;
      padding: 4px 12px;
      cursor: pointer;
      z-index: 9999;
    }

    .trip-save-btn {
      min-width: 250px;
      background: #28a745;
      color: #fff;
      border-radius: 7px;
      border: 0;
      padding: 7px 26px;
      font-weight: 600;
      font-size: 16px;
      cursor: pointer;
    }

    /* Gallery Header Styles */
    .gallery-header {
      text-align: center;
      margin-top: 20px;
    }

    .gallery-subtitle {
      opacity: .85;
    }

    .gallery-tags {
      margin-top: 6px;
      font: 14px/1.2 -apple-system, BlinkMacSystemFont, sans-serif;
      color: #555;
    }

    /* Editor Toolbar Button Styles */
    .editor-btn {
      padding: 6px 10px;
      border: 0;
      border-radius: 6px;
      color: #fff;
      cursor: pointer;
      font-size: 14px;
    }

    .editor-btn-primary {
      background: #2ca2d7;
    }

    .editor-btn-danger {
      background: #ff0066;
    }

    .editor-btn-purple {
      background: #6f42c1;
    }

    .editor-btn-orange {
      background: #ff6600;
    }

    .editor-btn-gray {
      background: #cccccc;
      color: #333;
    }

    .editor-btn-success {
      background: #28a745;
    }

    .editor-btn-large {
      padding: 6px 20px;
    }

    .editor-btn-xl {
      padding: 6px 40px;
    }

    /* Modal Styles */
    .modal-content {
      background: #111;
      color: #fff;
      padding: 16px;
      border-radius: 10px;
      min-width: 320px;
      max-width: 90vw;
      font: 14px/1.2 -apple-system, BlinkMacSystemFont, sans-serif;
    }

    .modal-input {
      width: 100%;
      margin-bottom: 8px;
    }

    .modal-buttons {
      display: flex;
      gap: 8px;
      justify-content: flex-end;
    }

    .modal-btn {
      padding: 6px 10px;
      border: 0;
      border-radius: 6px;
      background: #0a84ff;
      color: #fff;
      cursor: pointer;
    }

    /* Sub-location Editor Styles */
    .sub-location-controls {
      display: flex;
      align-items: center;
      gap: 5px;
    }

    .sub-location-select {
      flex: 1;
      padding: 6px;
      font-size: 12px;
      border: 1px solid #ddd;
      border-radius: 6px;
    }

    .location-map-btn {
      padding: 6px 10px;
      font-size: 11px;
    }

    /* Perspectives Panel */
    .perspectives-setup {
      background: white;
      border: 2px solid #667eea;
      border-radius: 12px;
      padding: 20px;
      margin: 20px 0;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
    }

    .perspectives-setup h3 {
      margin: 0 0 15px 0;
      color: #667eea;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .perspective-item-setup {
      position: relative;
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px 10px;
      background: #f8f9fa;
      border-radius: 8px;
      margin-bottom: 8px;
    }

    .perspective-fields {
      display: flex;
      flex-direction: column;
      gap: 6px;
      flex: 1;
      min-width: 0; /* Allow shrinking */
    }

    .perspective-color-picker {
      width: 24px;
      height: 24px;
      border: 2px solid #ddd;
      border-radius: 50%;
      cursor: pointer;
      padding: 0;
      flex-shrink: 0;
    }

    .perspective-name-input {
      width: 100%;
      padding: 6px 8px;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-size: 13px;
      font-weight: 600;
      box-sizing: border-box;
    }

    .perspective-desc-input {
      width: 100%;
      padding: 5px 8px;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-size: 11px;
      box-sizing: border-box;
    }

    .remove-perspective-btn {
      position: absolute;
      top: 6px;
      right: 6px;
      background: #dc3545;
      color: white;
      border: none;
      padding: 2px 6px;
      border-radius: 3px;
      cursor: pointer;
      font-size: 11px;
      z-index: 10;
      line-height: 1;
    }

    .remove-perspective-btn:hover {
      background: #c82333;
    }

    .add-perspective-btn {
      background: #28a745;
      color: white;
      border: none;
      padding: 10px 16px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 600;
    }

    .add-perspective-btn:hover {
      background: #218838;
    }

    /* Current Perspective Selector */
    .current-perspective-bar {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      padding: 15px 20px;
      border-radius: 12px;
      margin: 20px 0;
      display: flex;
      align-items: center;
      gap: 15px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      transition: background 0.3s ease;
    }

    .current-perspective-bar label {
      color: white;
      font-weight: 600;
      font-size: 16px;
      margin: 0;
    }

    .current-perspective-select {
      flex: 1;
      padding: 10px 15px;
      border: 2px solid white;
      border-radius: 8px;
      font-size: 15px;
      font-weight: 600;
      background: white;
      cursor: pointer;
    }

    /* Inline Waypoint Editor - Shows below card when editing waypoints */
    .waypoint-editor-inline {
      display: none;
      grid-column: 1 / -1;
      /* Span full width */
      background: #f8f9fa;
      border-radius: 12px;
      padding: 24px;
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.15);
      margin-bottom: 24px;
    }

    .waypoint-editor-inline.active {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 32px;
    }

    .waypoint-photo-large {
      position: relative;
      border-radius: 8px;
      overflow: hidden;
      background: #000;
      cursor: crosshair;
      min-height: 500px;
    }

    .waypoint-photo-large img {
      width: 100%;
      height: auto;
      display: block;
    }

    /* Replace icon for large waypoint editor photo */
    .waypoint-photo-large .replace-photo-icon {
      position: absolute;
      top: 12px;
      right: 12px;
      cursor: pointer;
    }

    .waypoint-dot {
      position: absolute;
      width: 32px;
      height: 32px;
      border-radius: 50%;
      background: rgba(255, 0, 102, 0.8);
      border: 2px solid #fff;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 18px;
      cursor: pointer;
      transform: translate(-50%, -50%);
      transition: all 0.2s ease;
    }

    .waypoint-dot:hover {
      transform: translate(-50%, -50%) scale(1.2);
      z-index: 10;
    }

    .waypoint-editor-panel {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .waypoint-editor-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding-bottom: 16px;
      border-bottom: 2px solid #dee2e6;
    }

    .waypoint-editor-header h3 {
      margin: 0;
      color: #333;
      font-size: 20px;
    }

    .waypoint-close-btn {
      background: #6c757d;
      color: #fff;
      border: none;
      padding: 8px 16px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
    }

    .waypoint-close-btn:hover {
      background: #5a6268;
    }

    .waypoint-form-group {
      display: flex;
      flex-direction: column;
      gap: 3px;
    }

    .waypoint-form-group label {
      display: none;
      /* Hide labels - using placeholders instead */
    }

    .waypoint-form-input {
      padding: 10px 12px;
      border: 1px solid #ced4da;
      border-radius: 6px;
      font-size: 14px;
      font-family: inherit;
    }

    .waypoint-form-input:focus {
      outline: none;
      border-color: #667eea;
      box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
    }

    .waypoint-list {
      background: #fff;
      border-radius: 6px;
      padding: 12px;
    }

    .waypoint-list-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 10px;
      background: #f8f9fa;
      border-radius: 6px;
      margin-bottom: 8px;
      cursor: pointer;
      transition: all 0.2s;
    }

    .waypoint-list-item:hover {
      background: #e9ecef;
    }

    .waypoint-list-item.active {
      background: #667eea;
      color: #fff;
    }

    /* Waypoint Modal Styles (keep for backwards compatibility) */
    .waypoint-modal {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.7);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10001;
    }

    .waypoint-modal-content {
      background: #1a1a1a;
      color: #fff;
      padding: 20px;
      border-radius: 10px;
      min-width: 350px;
      max-width: 500px;
      font: 14px/1.4 -apple-system, BlinkMacSystemFont, sans-serif;
    }

    .waypoint-input {
      width: 100%;
      padding: 8px 12px;
      background: #2a2a2a;
      color: #fff;
      border: 1px solid #444;
      border-radius: 6px;
      font-family: inherit;
      font-size: 14px;
      box-sizing: border-box;
    }

    .waypoint-input:focus {
      outline: none;
      border-color: #0a84ff;
      background: #333;
    }

    .edit-waypoint {
      background: #0a84ff;
      color: white;
      border: none;
      padding: 4px 8px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
      margin-left: 4px;
    }

    .edit-waypoint:hover {
      background: #0066cc;
    }

    /* Emoji Picker Styles */
    .emoji-picker {
      margin-top: 4px;
    }

    .emoji-picker-toggle {
      background: #6c757d;
      color: white;
      border: none;
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 11px;
      cursor: pointer;
      margin-bottom: 6px;
    }

    .emoji-picker-toggle:hover {
      background: #545b62;
    }

    .emoji-categories {
      display: none;
      background: #fff;
      border: 1px solid #dee2e6;
      border-radius: 6px;
      padding: 8px;
      margin-top: 4px;
    }

    .emoji-categories.show {
      display: block;
    }

    .emoji-category {
      margin-bottom: 8px;
    }

    .emoji-category:last-child {
      margin-bottom: 0;
    }

    .emoji-category-label {
      font-size: 10px;
      font-weight: 600;
      color: #6c757d;
      margin-bottom: 4px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .emoji-buttons {
      display: flex;
      flex-wrap: wrap;
      gap: 2px;
    }

    .emoji-btn {
      background: none;
      border: none;
      font-size: 16px;
      padding: 4px;
      border-radius: 4px;
      cursor: pointer;
      transition: background-color 0.15s ease;
    }

    .emoji-btn:hover {
      background: #f8f9fa;
    }

    /* Utility Classes */
    .no-locations-message {
      color: #666;
      font-style: italic;
    }

    .margin-top-none {
      margin-top: 0;
    }

    .margin-top-20 {
      margin-top: 20px;
    }

    .text-left {
      text-align: left;
    }



    #templateNav {
      right: 20px;
      position: absolute;
      display: block;
      text-align: center;
      width: 100%;
      max-width: 125px;
      background-color: rgb(40, 167, 69);
      font-weight: 600;
      color: white;
      padding: 10px;
      font-size: 14px;
      border-radius: 10px;
    }

    #templateNav a,
    #templateNav a:link,
    #templateNav a:visited,
    #templateNav a:focus {
      text-decoration: none;
      color: #ffffff;
      font-size: 14px;
      font-weight: 600;
    }

    #templateNav a:hover {
      letter-spacing: 1.5px;
      font-weight: 800;
    }
  </style>


  <style>
    .preset-btn:hover {
      border-color: #6366f1 !important;
      background: #f5f7ff !important;
    }

    .preset-btn.active {
      border-color: #6366f1 !important;
      background: #eef2ff !important;
    }

    #spreadSlider::-webkit-slider-thumb {
      appearance: none;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: #6366f1;
      cursor: pointer;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    }

    #spreadSlider::-moz-range-thumb {
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: #6366f1;
      cursor: pointer;
      border: none;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    }
  </style>


</head>

<body>

  <div id="templateNav"><a href="../spatial">Spatial View</a>
    <!--a href="../creator?edit=1">‚úèÔ∏è Edit</a-->
  </div>

  <!-- Vertical Navigation Tabs (collapsed, slide out on hover) -->
  <div class="preview-tabs">
    <button class="preview-tab" data-template="spatial">Spatial</button>
    <!--
  <button class="preview-tab" data-template="mystery">Mystery</button>
  <button class="preview-tab" data-template="timeline">Timeline</button>
  <button class="preview-tab" data-template="location">Location</button>
-->
  </div>
  <!-- Preview Panel -->
  <div id="preview-panel"
    style="display: none; position: fixed; top: 75px; right: 0; width: 50vw; height: 100vh; background: white; box-shadow: -4px 0 12px rgba(0,0,0,0.3); z-index: 999;">
    <button id="close-preview"
      style="border: none; color: white; font-size: 12px; cursor: pointer; padding: 0; width: 100px; height: 20px; position: absolute; z-index: 900; right: 10px; padding: 2px; background: rgb(142, 1, 1); border-radius:10px; margin: 10px 0 0 0;">close
      preview &times;</button>
    <div
      style="background: #343a40; color: white; padding: 12px 20px; display: flex; justify-content: space-between; align-items: center;">
      <span id="preview-title" style="font-weight: 600; font-size: 16px;">Gallery Preview</span>

    </div>
    <iframe id="preview-iframe" style="width: 100%; height: calc(100vh - 48px); border: none;"></iframe>
  </div>

  <!-- Editor Content -->
  <div class="editor-content">
    <div id="editor-space"></div>



    <div id="trip-settings-overlay" class="trip-overlay">
      <div>
        <div>
          <!--strong>üåç Edit Trip Settings</strong-->
          <button id="trip-settings-close" class="trip-close-btn">‚úï</button>
        </div>
        <div class="trip-settings">
          <h3 class="margin-top-none">Main Location</h3>
          <div class="country-selector">
            <label for="countrySelect">
              <div id="countryStatus" class="auto-detected">Please Select A Main Location:</div>
            </label>
            <select id="countrySelectPopup">
              <option value="">Choose A Main Location...</option>
              <option value="italy">üáÆüáπ Italy</option>
              <option value="usa">üá∫üá∏ United States</option>
              <option value="germany">üá©üá™ Germany</option>
              <option value="canada">üá®üá¶ Canada</option>
              <option value="world">üåç World (Multiple Countries)</option>
            </select>
          </div>
          <div class="margin-top-20 text-left">
            <button id="trip-settings-save" class="trip-save-btn">üíæ Save</button>
          </div>
        </div>
      </div>
    </div>



    <!-- HTML: Add this to your gallery settings panel -->
    <div class="spatial-spread-control"
      style="padding: 1rem; background: #f9fafb; border-radius: 8px; margin: 1rem 0; display: none;">
      <h3 style="margin-bottom: 0.5rem; font-size: 1.1rem; color: #374151;">
        üìê Gallery Layout Style
      </h3>
      <p style="font-size: 0.9rem; color: #6b7280; margin-bottom: 1rem;">
        Control how spread out photos appear in spatial view
      </p>

      <!-- OPTION 1: Preset Buttons (Simplest for users) -->
      <div class="spread-presets" style="display: flex; gap: 0.5rem; margin-bottom: 1rem;">
        <button class="preset-btn" data-spread="tight"
          style="flex: 1; padding: 0.75rem; border: 2px solid #e5e7eb; background: white; border-radius: 6px; cursor: pointer; transition: all 0.2s;">
          <div style="font-weight: 600; margin-bottom: 0.25rem;">ü§ù Tight</div>
          <div style="font-size: 0.75rem; color: #6b7280;">Show relationships</div>
        </button>

        <button class="preset-btn active" data-spread="balanced"
          style="flex: 1; padding: 0.75rem; border: 2px solid #6366f1; background: #eef2ff; border-radius: 6px; cursor: pointer; transition: all 0.2s;">
          <div style="font-weight: 600; margin-bottom: 0.25rem;">‚öñÔ∏è Balanced</div>
          <div style="font-size: 0.75rem; color: #6b7280;">Default</div>
        </button>

        <button class="preset-btn" data-spread="spread"
          style="flex: 1; padding: 0.75rem; border: 2px solid #e5e7eb; background: white; border-radius: 6px; cursor: pointer; transition: all 0.2s;">
          <div style="font-weight: 600; margin-bottom: 0.25rem;">üåü Spread Out</div>
          <div style="font-size: 0.75rem; color: #6b7280;">Showcase each</div>
        </button>

        <button class="preset-btn" data-spread="maximum"
          style="flex: 1; padding: 0.75rem; border: 2px solid #e5e7eb; background: white; border-radius: 6px; cursor: pointer; transition: all 0.2s;">
          <div style="font-weight: 600; margin-bottom: 0.25rem;">üé® Maximum</div>
          <div style="font-size: 0.75rem; color: #6b7280;">Full canvas</div>
        </button>
      </div>

      <!-- OPTION 2: Slider (More granular control) -->
      <div class="spread-slider" style="margin-top: 1rem; padding-top: 1rem; border-top: 1px solid #e5e7eb;">
        <label style="display: block; font-size: 0.9rem; color: #374151; margin-bottom: 0.5rem;">
          Custom Spread: <span id="spreadValue">0.6</span>
        </label>
        <input type="range" id="spreadSlider" min="0.3" max="1.0" step="0.05" value="0.6"
          style="width: 100%; height: 6px; border-radius: 3px; background: #e5e7eb; outline: none; cursor: pointer;">
        <div
          style="display: flex; justify-content: space-between; font-size: 0.75rem; color: #9ca3af; margin-top: 0.25rem;">
          <span>More Spread</span>
          <span>Semantic Clustering</span>
        </div>
      </div>

      <!-- Preview indicator -->
      <div
        style="margin-top: 1rem; padding: 0.75rem; background: white; border-radius: 6px; border: 1px solid #e5e7eb;">
        <div style="font-size: 0.85rem; color: #6b7280;">
          <strong>Current Style:</strong> <span id="currentStyle">Balanced</span>
        </div>
        <div style="font-size: 0.75rem; color: #9ca3af; margin-top: 0.25rem;">
          <span id="styleDescription">Good balance between relationships and visual clarity</span>
        </div>
      </div>
    </div>



    <!-- Perspectives Setup Panel - REMOVED, now in Creator Bridge below -->

    <!-- Settings Tabs (Layout & Perspectives) -->
    <div class="settings-tabs">
      <button class="settings-tab" data-panel="layout">üìê Layout Style</button>
      <button class="settings-tab" data-panel="perspectives">üëÅÔ∏è Perspectives</button>
    </div>

    <!-- Layout Panel -->
    <div id="layout-panel" class="settings-panel" style="display: none; position: fixed; top: 0; right: 0; width: 320px; height: 100vh; background: rgba(0,0,0,0.9); box-shadow: -4px 0 12px rgba(0,0,0,0.3); z-index: 999; overflow-y: auto; padding: 20px;">
      <button class="panel-close" data-panel="layout" style="position: absolute; top: 10px; right: 10px; background: rgba(255,255,255,0.1); border: none; color: white; width: 28px; height: 28px; border-radius: 6px; cursor: pointer; font-size: 18px;">√ó</button>

      <div class="bridge-section">
        <h4>üìê Layout Style</h4>

          <!-- Preset Buttons -->
          <div class="spread-presets"
            style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 0.5rem; margin-bottom: 1rem;">
            <button class="preset-btn" data-spread="tight"
              style="padding: 0.75rem; border: 2px solid #e5e7eb; background: white; border-radius: 6px; cursor: pointer; transition: all 0.2s;">
              <div style="font-weight: 600; margin-bottom: 0.25rem; font-size: 0.85em;">ü§ù Tight</div>
              <div style="font-size: 0.7rem; color: #6b7280;">Relationships</div>
            </button>

            <button class="preset-btn active" data-spread="balanced"
              style="padding: 0.75rem; border: 2px solid #6366f1; background: #eef2ff; border-radius: 6px; cursor: pointer; transition: all 0.2s;">
              <div style="font-weight: 600; margin-bottom: 0.25rem; font-size: 0.85em;">‚öñÔ∏è Balanced</div>
              <div style="font-size: 0.7rem; color: #6b7280;">Default</div>
            </button>

            <button class="preset-btn" data-spread="spread"
              style="padding: 0.75rem; border: 2px solid #e5e7eb; background: white; border-radius: 6px; cursor: pointer; transition: all 0.2s;">
              <div style="font-weight: 600; margin-bottom: 0.25rem; font-size: 0.85em;">üåü Spread</div>
              <div style="font-size: 0.7rem; color: #6b7280;">Showcase</div>
            </button>

            <button class="preset-btn" data-spread="maximum"
              style="padding: 0.75rem; border: 2px solid #e5e7eb; background: white; border-radius: 6px; cursor: pointer; transition: all 0.2s;">
              <div style="font-weight: 600; margin-bottom: 0.25rem; font-size: 0.85em;">üé® Maximum</div>
              <div style="font-size: 0.7rem; color: #6b7280;">Full canvas</div>
            </button>
          </div>

          <!-- Custom Slider -->
          <div class="spread-slider" style="padding-top: 1rem; border-top: 1px solid rgba(255, 255, 255, 0.1);">
            <label style="display: block; font-size: 0.85rem; color: white; margin-bottom: 0.5rem;">
              Custom Spread: <span id="spreadValue">0.6</span>
            </label>
            <input type="range" id="spreadSlider" min="0.3" max="1.0" step="0.05" value="0.6"
              style="width: 100%; height: 6px; border-radius: 3px; background: rgba(255,255,255,0.2); outline: none; cursor: pointer;">
            <div
              style="display: flex; justify-content: space-between; font-size: 0.7rem; color: rgba(255,255,255,0.6); margin-top: 0.25rem;">
              <span>More Spread</span>
              <span>Clustering</span>
            </div>
          </div>

          <!-- Current Style Display -->
          <div style="margin-top: 1rem; padding: 0.75rem; background: rgba(255,255,255,0.1); border-radius: 6px;">
            <div style="font-size: 0.8rem; color: white;">
              <strong>Current:</strong> <span id="currentStyle">Balanced</span>
            </div>
            <div style="font-size: 0.7rem; color: rgba(255,255,255,0.7); margin-top: 0.25rem;">
              <span id="styleDescription">Good balance between relationships and visual clarity</span>
            </div>
          </div>
        </div>
    </div>

    <!-- Perspectives Panel -->
    <div id="perspectives-panel" class="settings-panel" style="display: none; position: fixed; top: 0; right: 0; width: 320px; height: 100vh; background: rgba(0,0,0,0.9); box-shadow: -4px 0 12px rgba(0,0,0,0.3); z-index: 999; overflow-y: auto; padding: 20px;">
      <button class="panel-close" data-panel="perspectives" style="position: absolute; top: 10px; right: 10px; background: rgba(255,255,255,0.1); border: none; color: white; width: 28px; height: 28px; border-radius: 6px; cursor: pointer; font-size: 18px;">√ó</button>

      <div class="bridge-section">
        <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 0.75em;">
          <h4 style="margin: 0; cursor: pointer; display: flex; align-items: center; gap: 0.3em;"
            onclick="togglePerspectivesSection()">
            <span>üëÅÔ∏è Perspectives</span>
            <span id="perspectivesToggleIcon" style="font-size: 0.7em;">‚ñº</span>
          </h4>
          <button class="add-perspective-btn" onclick="addPerspective()"
            style="padding: 0.4em 0.8em; background: rgba(102, 126, 234, 0.3); border: 1px solid rgba(102, 126, 234, 0.5); color: white; border-radius: 4px; cursor: pointer; font-size: 0.75em; transition: all 0.2s; font-weight: 600;">
            + ADD
          </button>
        </div>
        <div id="perspectivesContent">
          <div id="perspectivesList" class="bridge-perspectives-list" style="max-height: calc(100vh - 140px); overflow-y: auto;">
          </div>
        </div>
      </div>
    </div>

    <!-- Current Perspective Selector -->
    <div class="current-perspective-bar" id="currentPerspectiveBar">
      <div style="display: flex; flex-direction: column; gap: 4px; flex: 1;">
        <label style="font-weight: 600;">üë§ Current Perspective</label>
        <small style="color: rgba(255,255,255,0.8); font-size: 11px;">Sets all unassigned photos & waypoints to this
          perspective</small>
      </div>
      <select class="current-perspective-select" id="currentPerspectiveSelect" onchange="switchPerspective()">
        <option value="">-- Select your perspective --</option>
      </select>
    </div>

    <!-- Add Photo Buttons -->
    <div style="padding: 16px; text-align: center; display: flex; gap: 12px; justify-content: center; flex-wrap: wrap;">
      <button class="add-photo-btn" onclick="showTemplatePhoto()"
        style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border: none; padding: 12px 24px; border-radius: 8px; cursor: pointer; font-size: 16px; font-weight: 600; box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3); transition: transform 0.2s;">
        üì∑ + Add Single Photo
      </button>

      <button class="add-photo-btn" onclick="document.getElementById('multiPhotoInput').click()"
        style="background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); color: white; border: none; padding: 12px 24px; border-radius: 8px; cursor: pointer; font-size: 16px; font-weight: 600; box-shadow: 0 4px 12px rgba(240, 147, 251, 0.3); transition: transform 0.2s;">
        üñºÔ∏è + Upload Multiple Photos
      </button>
      <input type="file" id="multiPhotoInput" accept="image/*" multiple style="display: none;"
        onchange="handleMultiPhotoUpload(event)">
    </div>

    <!-- Upload Progress -->
    <div id="uploadProgress"
      style="display: none; padding: 12px 16px; margin: 0 16px; background: rgba(0,123,255,0.1); border-radius: 8px; text-align: center;">
      <div style="color: #007bff; font-weight: 600; margin-bottom: 8px;">Uploading photos...</div>
      <div style="background: #e9ecef; border-radius: 4px; height: 8px; overflow: hidden;">
        <div id="uploadProgressBar"
          style="background: linear-gradient(90deg, #007bff, #0056b3); height: 100%; width: 0%; transition: width 0.3s;">
        </div>
      </div>
      <div id="uploadStatus" style="color: #6c757d; font-size: 13px; margin-top: 8px;">0 of 0 photos</div>
    </div>

    <div class="gallery-header">
      <h1 id="galleryTitle" contenteditable="true" data-placeholder="Click to edit title...">Need to update structure of
        json tot re-include title</h1>
      <h2 id="gallerySubtitle" class="gallery-subtitle" contenteditable="true"
        data-placeholder="Click to add subtitle...">
        Sub title</h2>
      <div id="galleryTags" class="gallery-tags" contenteditable="true"
        data-placeholder="Add travelers (separate with ‚Ä¢)">
        traveler1 ‚Ä¢ traveler2 ‚Ä¢ traveler3 (travels are prespecives)</div>
    </div>

    <div id="accid-next-steps_gallery"></div>
    <div id="grid" class="photo-grid">
      <!-- Photos will be inserted here dynamically -->

      <!-- Inline Waypoint Editor (inserted dynamically when editing) -->
      <div id="waypointEditorInline" class="waypoint-editor-inline">
        <div class="waypoint-photo-large" id="waypointPhotoLarge">
          <img src="" alt="Photo" id="waypointPhotoImg">
          <div class="replace-photo-icon" onclick="replacePhotoForCard(this)" title="Replace Photo">üîÑ</div>
          <!-- Waypoint dots will be added here dynamically -->
        </div>

        <div class="waypoint-editor-panel">
          <div class="waypoint-editor-header">
            <h3>üìç Edit Waypoints</h3>
            <button class="waypoint-close-btn" onclick="closeInlineWaypointEditor()">‚úï Close</button>
          </div>

          <p style="color: #666; font-size: 13px; margin: 0;">Click on the photo to add waypoints. Click existing
            waypoints to edit them.</p>

          <!-- Waypoint List -->
          <div class="waypoint-form-group">
            <label>Waypoints on this photo:</label>
            <div class="waypoint-list" id="waypointListInline">
              <p style="color: #999; font-size: 13px; margin: 0;">No waypoints yet. Click on the photo to add one!</p>
            </div>
          </div>

          <!-- Current Waypoint Editor (shown when a waypoint is selected) -->
          <div id="waypointFormInline" style="display: none;">
            <div class="waypoint-form-group">
              <label>Waypoint Type</label>
              <select class="waypoint-form-input" id="waypointTypeInline">
                <option value="rest-stop">üõë Rest Stop - Basic info</option>
                <option value="info">üìÑ Info - Detailed steps/details</option>
                <option value="grouper">üìÅ Grouper - Hub connecting multiple waypoints</option>
              </select>
            </div>

            <div class="waypoint-form-group">
              <label>Title</label>
              <input type="text" class="waypoint-form-input" id="waypointTitleInline"
                placeholder="Title - e.g., Peace Sign at Airport">
            </div>

            <div class="waypoint-form-group">
              <label>Emoji</label>
              <input type="text" class="waypoint-form-input" id="waypointEmojiInline" placeholder="Emoji - e.g., ‚úåÔ∏è"
                maxlength="4">
            </div>

            <div class="waypoint-form-group">
              <label>Description</label>
              <textarea class="waypoint-form-input" id="waypointDescInline"
                placeholder="Description - What happened here?" rows="2"></textarea>
            </div>

            <div class="waypoint-form-group">
              <label>Link to Another Photo</label>
              <select class="waypoint-form-input" id="waypointLinkInline">
                <option value="">üîó Link to Another Photo - None</option>
              </select>
            </div>

            <div class="waypoint-form-group">
              <label>Info Terms (comma-separated)</label>
              <input type="text" class="waypoint-form-input" id="waypointTermsInline"
                placeholder="Info Terms - e.g., building, crowd, man">
              <small style="color: #999; font-size: 11px; margin-top: 4px; display: block;">Tags help connect related
                waypoints and photos</small>
            </div>

            <!-- Connected Waypoints Preview -->
            <div class="waypoint-form-group" id="connectedWaypointsPreviewInline" style="display: none;">
              <label>Connected Waypoints</label>
              <div style="background: #f8f9fa; border-radius: 6px; padding: 10px; font-size: 12px; color: #666;"
                id="connectedWaypointsListInline">
                <!-- Populated dynamically based on matching info terms -->
              </div>
              <small style="color: #999; font-size: 11px; margin-top: 4px; display: block;">Waypoints with matching info
                terms</small>
            </div>

            <div style="display: flex; gap: 8px; margin-top: 16px;">
              <button onclick="saveCurrentWaypoint()"
                style="flex: 1; padding: 10px; background: #28a745; color: #fff; border: none; border-radius: 6px; cursor: pointer; font-weight: 600;">‚úì
                Save Waypoint</button>
              <button onclick="deleteCurrentWaypoint()"
                style="padding: 10px 16px; background: #dc3545; color: #fff; border: none; border-radius: 6px; cursor: pointer;">üóëÔ∏è
                Delete</button>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Universal Grid System Location Editor -->
    <div id="gridOverlay" class="grid-overlay">
      <div class="grid-editor">
        <h2>üì∏ Edit Locations on Photo</h2>
        <div class="map-container" id="mapContainer">
          <!-- Country map will be rendered here dynamically -->
          <div class="universal-grid" id="universalGrid"></div>
        </div>
        <div class="grid-controls">
          <button class="save-locations" onclick="saveLocations()">üíæ Save Locations</button>
          <button class="upload-photo-btn" onclick="uploadPhotoForCard()"
            style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);">üì§ Upload New Photo</button>
          <button class="cancel-locations" onclick="closeLocationEditor()">‚ùå Close Overlay</button>
          <button class="clear-locations" onclick="clearAllLocations()">üóëÔ∏è Clear All</button>
        </div>
        <div class="location-list" id="locationList"></div>
      </div>
    </div>

    <!-- Waypoint Editor Modal -->
    <div id="waypointModal" class="waypoint-modal" style="display:none;">
      <div class="waypoint-modal-content">
        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:16px;">
          <strong style="font-size:16px;">Edit Waypoint Info</strong>
          <button id="waypoint-close"
            style="background:#444;color:#fff;border:0;border-radius:6px;padding:4px 8px;cursor:pointer;font-size:16px;">‚úï</button>
        </div>

        <label style="display:block;margin-bottom:4px;font-weight:600;">Waypoint Type</label>
        <select id="waypoint-type" class="waypoint-input" style="margin-bottom:12px;">
          <option value="rest-stop">üõë Rest Stop - Basic waypoint info</option>
          <option value="info">üìÑ Info - Detailed steps/details</option>
          <option value="grouper">üìÅ Grouper - Hub connecting multiple waypoints</option>
        </select>

        <label style="display:none;">Waypoint Title</label>
        <input id="waypoint-title" class="waypoint-input" placeholder="Title - e.g., Colosseum, Trevi Fountain"
          style="margin-bottom:8px;">

        <label style="display:none;">Description</label>
        <textarea id="waypoint-description" class="waypoint-input" placeholder="Description - What happened here?"
          style="margin-bottom:8px;height:48px;resize:vertical;"></textarea>

        <label style="display:none;">Info Terms (comma-separated)</label>
        <input id="waypoint-info-terms" class="waypoint-input"
          placeholder="Info Terms - e.g., history, architecture, crowds, food" style="margin-bottom:8px;">

        <label style="display:none;">üëÅÔ∏è Perspective</label>
        <select id="waypoint-perspective" class="waypoint-input" style="margin-bottom:8px;">
          <option value="">üëÅÔ∏è No Perspective</option>
          <!-- Populated dynamically from perspectives array -->
        </select>

        <label style="display:none;">üîó Link to Another Photo</label>
        <select id="waypoint-linked-photo" class="waypoint-input" style="margin-bottom:8px;">
          <option value="">üîó Link to Another Photo - None</option>
          <!-- Populated dynamically from gallery-data.json -->
        </select>

        <label style="display:none;">Emoji</label>
        <input id="waypoint-emoji" class="waypoint-input" placeholder="Emoji - e.g., üìç" maxlength="4"
          style="margin-bottom:8px;">

        <label style="display:none;">Opacity (0.0 - 1.0)</label>
        <input id="waypoint-opacity" class="waypoint-input" type="number" min="0" max="1" step="0.1" value="1.0"
          placeholder="Opacity (0.0 - 1.0)" style="margin-bottom:8px;">

        <div id="waypoint-connections-preview"
          style="margin-bottom:12px;padding:8px;background:#2a2a2a;border-radius:6px;display:none;">
          <strong style="font-size:12px;color:#aaa;">Connected Waypoints:</strong>
          <div id="waypoint-connections-list" style="font-size:12px;color:#ccc;margin-top:4px;"></div>
        </div>

        <div style="display:flex;gap:8px;justify-content:flex-end;">
          <button id="waypoint-save" class="modal-btn" style="background:#28a745;">Save</button>
          <button id="waypoint-cancel" class="modal-btn" style="background:#6c757d;">Cancel</button>
        </div>
      </div>
    </div>

    <script>

      // Country name mapping function - pulls from country-paths.js
      function getCountryDisplayName(isoCode) {
        // Try to get country from country-paths.js
        if (typeof getCountry === 'function') {
          const country = getCountry(isoCode);
          if (country && country.name) {
            return country.name;
          }
        }

        // Fallback to uppercase ISO code
        return isoCode.toUpperCase();
      }

      function toggleWaypointFields(filename, selectedType) {
        // Hide all waypoint type fields for this photo
        document.querySelectorAll(`[class^="waypoint-field-"][class$="-${filename}"]`).forEach(el => {
          el.style.display = 'none';
        });

        // Show only the selected type field
        const targetField = document.querySelector(`.waypoint-field-${selectedType}-${filename}`);
        if (targetField) {
          targetField.style.display = 'block';
        }
      }

      // Helper function to darken a hex color
      function darkenColor(hex, amount) {
        // Convert hex to RGB
        let r = parseInt(hex.slice(1, 3), 16);
        let g = parseInt(hex.slice(3, 5), 16);
        let b = parseInt(hex.slice(5, 7), 16);

        // Darken by reducing RGB values
        r = Math.max(0, Math.floor(r * (1 - amount)));
        g = Math.max(0, Math.floor(g * (1 - amount)));
        b = Math.max(0, Math.floor(b * (1 - amount)));

        // Convert back to hex
        return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
      }

      // Adjust color shade/tint based on similarity spectrum
      // Negative amount = add black (shade), Positive amount = add white (tint)
      function adjustColorShade(hex, amount) {
        // Convert hex to RGB
        let r = parseInt(hex.slice(1, 3), 16);
        let g = parseInt(hex.slice(3, 5), 16);
        let b = parseInt(hex.slice(5, 7), 16);

        if (amount < 0) {
          // Shade: add black (darken)
          const darkenFactor = Math.abs(amount);
          r = Math.max(0, Math.floor(r * (1 - darkenFactor)));
          g = Math.max(0, Math.floor(g * (1 - darkenFactor)));
          b = Math.max(0, Math.floor(b * (1 - darkenFactor)));
        } else if (amount > 0) {
          // Tint: add white (lighten)
          const lightenFactor = amount;
          r = Math.min(255, Math.floor(r + (255 - r) * lightenFactor));
          g = Math.min(255, Math.floor(g + (255 - g) * lightenFactor));
          b = Math.min(255, Math.floor(b + (255 - b) * lightenFactor));
        }
        // amount === 0 = no change (pure color)

        // Convert back to hex
        return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
      }

      // Perspectives Management
      let perspectives = [];
      let currentPerspective = null;

      function initializePerspectives() {
        // Load perspectives from GALLERY_DATA if they exist
        if (window.GALLERY_DATA && window.GALLERY_DATA.perspectives) {
          perspectives = window.GALLERY_DATA.perspectives;
        } else {
          // Default perspectives
          perspectives = [
            { name: 'Dad', color: '#4A90E2', desc: 'Engineering mind - notices technical details' },
            { name: 'Sister', color: '#F5D547', desc: 'Social media lens - notices aesthetic moments' },
            { name: 'Mom', color: '#50C878', desc: 'Organizer mindset - notices logistics and people' },
            { name: 'Photographer', color: '#FF8C42', desc: 'Artistic eye - notices composition and lighting' }
          ];
        }
        renderPerspectivesList();
        updatePerspectiveSelector();
      }

      function renderPerspectivesList() {
        const list = document.getElementById('perspectivesList');
        if (!list) return;

        list.innerHTML = perspectives.map((p, idx) => `
        <div class="perspective-item-setup">
          <button class="remove-perspective-btn" onclick="removePerspective(${idx})">‚úï</button>
          <input type="color" class="perspective-color-picker" value="${p.color}" onchange="updatePerspectiveColor(${idx}, this.value)">
          <div class="perspective-fields">
            <input type="text" class="perspective-name-input" value="${p.name}" onchange="updatePerspectiveName(${idx}, this.value)" placeholder="Name (e.g., Dad)">
            <input type="text" class="perspective-desc-input" value="${p.desc}" onchange="updatePerspectiveDesc(${idx}, this.value)" placeholder="Description">
          </div>
        </div>
      `).join('');
      }

      function togglePerspectivesSection() {
        const content = document.getElementById('perspectivesContent');
        const icon = document.getElementById('perspectivesToggleIcon');

        if (content.style.display === 'none') {
          content.style.display = 'block';
          icon.textContent = '‚ñº';
        } else {
          content.style.display = 'none';
          icon.textContent = '‚ñ∂';
        }
      }

      function updatePerspectiveSelector() {
        const selector = document.getElementById('currentPerspectiveSelect');
        if (!selector) return;

        const currentValue = selector.value;
        selector.innerHTML = '<option value="">-- Select who is adding waypoints --</option>' +
          perspectives.map(p => `<option value="${p.name}">${p.name}</option>`).join('');

        if (currentValue && perspectives.find(p => p.name === currentValue)) {
          selector.value = currentValue;
        }
      }

      function addPerspective() {
        const newPerspective = {
          name: 'New Perspective',
          color: '#' + Math.floor(Math.random() * 16777215).toString(16),
          desc: ''
        };
        perspectives.unshift(newPerspective);
        console.log('‚ûï Added new perspective:', newPerspective, 'Total perspectives:', perspectives.length);
        renderPerspectivesList();
        updatePerspectiveSelector();
        savePerspectivesToData();
        console.log('üíæ Saved perspectives to window.GALLERY_DATA:', window.GALLERY_DATA?.perspectives);
      }

      function removePerspective(idx) {
        perspectives.splice(idx, 1);
        renderPerspectivesList();
        updatePerspectiveSelector();
        savePerspectivesToData();
      }

      function updatePerspectiveColor(idx, color) {
        perspectives[idx].color = color;
        savePerspectivesToData();
        if (currentPerspective === perspectives[idx].name) {
          applyPerspectiveColor();
        }
      }

      function updatePerspectiveName(idx, name) {
        perspectives[idx].name = name;
        updatePerspectiveSelector();
        savePerspectivesToData();
      }

      function updatePerspectiveDesc(idx, desc) {
        perspectives[idx].desc = desc;
        savePerspectivesToData();
      }

      function switchPerspective() {
        const selector = document.getElementById('currentPerspectiveSelect');
        currentPerspective = selector.value;
        applyPerspectiveColor();

        // Bulk assign: Set all unassigned photos to this perspective
        if (currentPerspective && window.GALLERY_DATA && window.GALLERY_DATA.photos) {
          let assignedCount = 0;
          window.GALLERY_DATA.photos.forEach(photo => {
            // Only assign if photo doesn't have a perspective yet
            if (!photo.photoPerspective && !photo.isTemplate) {
              photo.photoPerspective = currentPerspective;
              assignedCount++;
            }
          });

          if (assignedCount > 0) {
            console.log(`‚úÖ Bulk assigned ${assignedCount} unassigned photos to ${currentPerspective}`);
            // Refresh the display to show the assignments
            const grid = document.getElementById('grid');
            if (grid) {
              // Update the perspective selectors in the cards
              const cards = grid.querySelectorAll('.card');
              cards.forEach(card => {
                const filename = card.dataset.filename;
                const photo = window.GALLERY_DATA.photos.find(p => p.filename === filename);
                if (photo && photo.photoPerspective) {
                  const perspectiveSelect = card.querySelector('.ef-photo-perspective');
                  if (perspectiveSelect) {
                    perspectiveSelect.value = photo.photoPerspective;
                  }
                }
              });
            }
          }
        }
      }

      function applyPerspectiveColor() {
        const bar = document.getElementById('currentPerspectiveBar');
        if (!currentPerspective) {
          bar.style.background = 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)';
          return;
        }

        const perspective = perspectives.find(p => p.name === currentPerspective);
        if (perspective) {
          bar.style.background = perspective.color;
        }
      }

      function togglePerspectivesPanel() {
        const panel = document.getElementById('perspectivesSetup');
        const list = document.getElementById('perspectivesList');
        const addBtn = panel.querySelector('.add-perspective-btn');

        if (list.style.display === 'none') {
          list.style.display = 'block';
          addBtn.style.display = 'block';
        } else {
          list.style.display = 'none';
          addBtn.style.display = 'none';
        }
      }

      function savePerspectivesToData() {
        if (window.GALLERY_DATA) {
          window.GALLERY_DATA.perspectives = perspectives;
        }
      }

      // Calculate similarity spectrum (0-1) for all waypoints
      function calculateSimilarities() {
        if (!window.GALLERY_DATA || !window.GALLERY_DATA.photos) {
          return;
        }

        let updatedCount = 0;

        // For each photo
        window.GALLERY_DATA.photos.forEach(photo => {
          if (!photo['sub-points']) return;

          // For each waypoint on the photo
          photo['sub-points'].forEach(waypoint => {
            // Clean up old agreement field if it exists
            if (waypoint.hasOwnProperty('agreement')) {
              delete waypoint.agreement;
            }

            if (!waypoint.perspective || !waypoint.infoTerms || waypoint.infoTerms.length === 0) {
              waypoint.similarity = 0; // No terms = no similarity
              return;
            }

            // Compare this waypoint with all other waypoints from different perspectives
            let totalComparisons = 0;
            let totalSimilarity = 0;

            // Look at all photos for comparison
            window.GALLERY_DATA.photos.forEach(otherPhoto => {
              if (!otherPhoto['sub-points']) return;

              otherPhoto['sub-points'].forEach(otherWaypoint => {
                // Don't compare with self or same perspective
                if (waypoint === otherWaypoint) return;
                if (!otherWaypoint.perspective) return;
                if (otherWaypoint.perspective === waypoint.perspective) return;

                // Calculate similarity using Jaccard index (same as spatial view)
                const termsA = waypoint.infoTerms || [];
                const termsB = otherWaypoint.infoTerms || [];

                if (termsA.length === 0 || termsB.length === 0) return;

                const shared = termsA.filter(t => termsB.includes(t)).length;
                const unique = new Set([...termsA, ...termsB]).size;
                const similarity = shared / unique;

                totalSimilarity += similarity;
                totalComparisons++;
              });
            });

            // Calculate average similarity with other perspectives (0-1 scale)
            if (totalComparisons > 0) {
              waypoint.similarity = totalSimilarity / totalComparisons;
              updatedCount++;
              console.log(`üé® ${waypoint.title || 'Waypoint'} (${waypoint.perspective}): similarity=${waypoint.similarity.toFixed(3)} (${getShadeDescription(waypoint.similarity)})`);
            } else {
              waypoint.similarity = 0; // No other perspectives to compare
            }
          });
        });

        if (updatedCount > 0) {
          console.log(`‚úÖ Calculated similarity spectrum for ${updatedCount} waypoints`);
        }

        return updatedCount;
      }

      function getShadeDescription(similarity) {
        if (similarity > 0.6) return 'bright tint - strong togetherness';
        if (similarity > 0.3) return 'pure color - some overlap';
        return 'dark shade - unique perspective';
      }

      // Reusable form generator for waypoints and assets
      // mode: 'modal', 'inline', 'asset'
      function renderWaypointAssetForm(data, index, filename, mode = 'modal') {
        const isAsset = mode === 'asset';
        const isModal = mode === 'modal';
        const isInline = mode === 'inline';

        // Get current values
        const title = data.title || data.name || '';
        const info = data.info || data.notes || '';
        const type = data.type || data.waypointType || 'rest-stop';
        const perspective = data.perspective || data.photoPerspective || '';
        const groupers = data.groupers || [];
        const infoTerms = data.infoTerms || [];
        const linkedPhotoId = data.linkedPhotoId || '';
        const similarity = data.similarity;

        // Type icons
        const typeIcons = {
          'rest-stop': 'üõë',
          'info': 'üìÑ',
          'grouper': 'üìÅ'
        };
        const typeIcon = typeIcons[type] || 'üìç';

        // ID prefix based on mode
        const idPrefix = isAsset ? `asset-${filename}` : `waypoint-${index}`;

        let html = '';

        // Modal header (only for modal mode)
        if (isModal) {
          html += `
          <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 12px 16px; margin: -12px -16px 16px -16px; border-radius: 8px 8px 0 0; display: flex; align-items: center; justify-content: space-between;">
            <div style="display: flex; align-items: center; gap: 8px;">
              <span style="font-size: 20px;">${typeIcon}</span>
              <select id="${idPrefix}-type" style="background: rgba(255,255,255,0.2); color: white; border: 1px solid rgba(255,255,255,0.3); padding: 6px 10px; border-radius: 6px; font-weight: 600; font-size: 14px;">
                <option value="rest-stop" ${type === 'rest-stop' ? 'selected' : ''}>üõë Rest Stop</option>
                <option value="info" ${type === 'info' ? 'selected' : ''}>üìÑ Info Detail</option>
                <option value="grouper" ${type === 'grouper' ? 'selected' : ''}>üìÅ Grouper</option>
              </select>
            </div>
            <span style="font-size: 12px; opacity: 0.9;">${isAsset ? 'Asset Info' : `Waypoint #${index + 1}`}</span>
          </div>
              <div style="display: flex; gap: 8px; margin-top: 16px;">
            <button class="save-waypoint-btn" onclick="saveWaypointChanges('${filename}', ${index})" style="flex: 1; background: #28a745; color: white; border: none; padding: 10px 16px; border-radius: 6px; cursor: pointer; font-weight: 600;">‚úì Save Changes</button>
          </div>
        `;
        }

        // Title
        html += `
        <label style="display: none;">Title:</label>
        <input type="text"
               id="${idPrefix}-title"
               class="${isAsset ? 'ef-title' : ''}"
               value="${title}"
               placeholder="${isAsset ? 'Photo title' : 'Title - e.g., Waypoint title'}"
               style="width: 100%; padding: 8px; border: 1px solid #dee2e6; border-radius: 4px; margin-bottom: 8px;">
      `;

        // Description
        html += `
        <label style="display: none;">Description:</label>
        <textarea
               id="${idPrefix}-info"
               class="${isAsset ? 'ef-notes' : ''}"
               placeholder="${isAsset ? 'Description - Describe this photo...' : 'Description - What\'s notable about this waypoint?'}"
               style="width: 100%; padding: 8px; border: 1px solid #dee2e6; border-radius: 4px; margin-bottom: 8px; resize: vertical; min-height: 48px;">${info}</textarea>
      `;

        // Type (if not in modal header)
        if (!isModal) {
          html += `
          <label style="display: none;">Type:</label>
          <select id="${idPrefix}-type" class="${isAsset ? 'ef-asset-type' : ''}" style="width: 100%; padding: 8px; border: 1px solid #dee2e6; border-radius: 4px; margin-bottom: 8px;">
            <option value="rest-stop" ${type === 'rest-stop' ? 'selected' : ''}>üõë Rest Stop</option>
            <option value="info" ${type === 'info' ? 'selected' : ''}>üìÑ Info Detail</option>
            <option value="grouper" ${type === 'grouper' ? 'selected' : ''}>üìÅ Grouper</option>
          </select>
        `;
        }

        // Perspective
        html += `
        <label style="display: none;">üëÅÔ∏è Perspective:</label>
        <select id="${idPrefix}-perspective" class="${isAsset ? 'ef-photo-perspective' : ''}" style="width: 100%; padding: 8px; border: 1px solid #dee2e6; border-radius: 4px; margin-bottom: 8px;">
          <option value="">üëÅÔ∏è Perspective - No perspective assigned</option>
          ${perspectives.map(p => `
            <option value="${p.name}" ${perspective === p.name ? 'selected' : ''}>
              ${p.name} - ${p.desc}
            </option>
          `).join('')}
        </select>
      `;

        // Waypoint-specific fields (not for assets)
        if (!isAsset && isModal) {
          // Link to another photo
          html += `
          <label style="display: none;">üîó Link to Photo:</label>
          <select id="${idPrefix}-link" style="width: 100%; padding: 8px; border: 1px solid #dee2e6; border-radius: 4px; margin-bottom: 8px;">
            <option value="">üîó Link to Photo - None</option>
          </select>
        `;

          // Groupers
          html += `
          <label style="display: none;">üìÅ Groupers:</label>
          <input type="text"
                 id="${idPrefix}-groupers"
                 value="${groupers.join(', ')}"
                 placeholder="üìÅ Groupers - e.g., category1, category2"
                 style="width: 100%; padding: 8px; border: 1px solid #dee2e6; border-radius: 4px; margin-bottom: 8px;">
          <small style="display: block; color: #999; font-size: 11px; margin-top: -4px; margin-bottom: 8px;">Comma-separated grouper categories</small>
        `;

          // Info Terms
          html += `
          <label style="display: none;">üè∑Ô∏è Info Terms:</label>
          <input type="text"
                 id="${idPrefix}-infoTerms"
                 value="${infoTerms.join(', ')}"
                 placeholder="üè∑Ô∏è Info Terms - e.g., man, crowd, building"
                 style="width: 100%; padding: 8px; border: 1px solid #dee2e6; border-radius: 4px; margin-bottom: 8px;">
          <small style="display: block; color: #999; font-size: 11px; margin-top: -4px; margin-bottom: 8px;">Tags help calculate similarity spectrum</small>
        `;

          // Similarity Display (read-only)
          if (similarity !== undefined) {
            html += `
            <div style="background: #f8f9fa; padding: 10px; border-radius: 6px; margin-bottom: 12px; border-left: 4px solid #667eea;">
              <strong style="color: #667eea;">üé® Similarity Spectrum:</strong>
              <span style="font-size: 16px; font-weight: 600;">${(similarity * 100).toFixed(0)}%</span>
              <small style="display: block; color: #666; margin-top: 4px;">Auto-calculated on save based on info terms</small>
            </div>
          `;
          }

          // Action Buttons
          html += `
          <div style="display: flex; gap: 8px; margin-top: 16px;">
            <button class="save-waypoint-btn" onclick="saveWaypointChanges('${filename}', ${index})" style="flex: 1; background: #28a745; color: white; border: none; padding: 10px 16px; border-radius: 6px; cursor: pointer; font-weight: 600;">‚úì Save Changes</button>
            <button class="remove-waypoint-btn" onclick="removeWaypoint('${filename}', ${index})" style="background: #dc3545; color: white; border: none; padding: 2px 4px; border-radius: 6px; cursor: pointer; font-weight: 600;">‚úï Remove</button>
          </div>
        `;
        }

        return html;
      }

      // Add Photo functionality - immediately creates a real photo (not a template)
      function showTemplatePhoto() {
        if (!window.GALLERY_DATA || !window.GALLERY_DATA.photos) {
          alert('‚ö†Ô∏è No gallery data loaded');
          return;
        }

        // Generate unique filename with timestamp
        const timestamp = Date.now();
        const newFilename = `photo_${timestamp}.jpg`;

        // Get max order
        const maxOrder = window.GALLERY_DATA.photos.reduce((max, p) =>
          Math.max(max, p.order || 0), -1);

        // Create new photo immediately (not a template!)
        const newPhoto = {
          filename: newFilename,
          location: '',
          day: null,
          title: 'Click to add title...',
          notes: '',
          faces: [],
          back_of_pic: '',
          mood: '',
          emoji: 'üì∑',
          favorite: false,
          color: 'var(--c1)',
          aspect_ratio: '16:9',
          cloudUrl: '',
          backupUrl: '',
          localPath: '../placeholder/placeholder.gif',
          size: 0,
          modified: '',
          caption: 'New Photo',
          'sub-point-name': '',
          'sub-point-position': '',
          'sub-point-row': 0,
          'sub-point-col': 0,
          'sub-point-x': 0,
          'sub-point-y': 0,
          order: maxOrder + 1,
          'sub-points': [],
          waypointType: 'rest-stop',
          restStopInfo: '',
          infoDetails: '',
          grouperDesc: '',
          infoTerms: []
        };

        // Auto-apply current perspective if one is selected
        if (currentPerspective) {
          newPhoto.photoPerspective = currentPerspective;
          console.log(`‚ú® Auto-applied perspective: ${currentPerspective}`);
        }

        // Add to data structure immediately
        window.GALLERY_DATA.photos.push(newPhoto);

        // Render new card
        const grid = document.getElementById('grid');
        const newCard = cardFor(newPhoto);
        newCard.draggable = true;

        // Make it editable
        newCard.querySelector('.caption').contentEditable = 'true';
        newCard.querySelector('.caption').style.outline = '1px dashed rgba(0,0,0,.3)';

        // Expand edit fields for single photo (user wants to edit immediately)
        const editFields = newCard.querySelector('.edit-fields');
        const toggleBtn = newCard.querySelector('.toggle-fields-btn');
        if (editFields) {
          editFields.style.display = 'block';
          // Update toggle button to show expanded state
          if (toggleBtn) {
            toggleBtn.innerHTML = '<span class="toggle-icon">‚ñ≤</span> Hide Details';
            toggleBtn.style.background = '#e7f3ff';
            toggleBtn.style.borderColor = '#667eea';
            toggleBtn.style.color = '#667eea';
          }
        }

        grid.appendChild(newCard);

        // Scroll to new card
        newCard.scrollIntoView({ behavior: 'smooth', block: 'center' });

        // Highlight it briefly
        newCard.style.outline = '4px solid #667eea';
        newCard.style.boxShadow = '0 0 20px rgba(102, 126, 234, 0.6)';
        setTimeout(() => {
          newCard.style.outline = '';
          newCard.style.boxShadow = '';
        }, 2000);

        console.log('üì∑ Created new photo:', newFilename);
      }

      // Handle multiple photo upload
      async function handleMultiPhotoUpload(event) {
        const files = Array.from(event.target.files);
        if (files.length === 0) return;

        if (!window.GALLERY_DATA || !window.GALLERY_DATA.photos) {
          alert('‚ö†Ô∏è No gallery data loaded');
          return;
        }

        // Show progress bar
        const progressContainer = document.getElementById('uploadProgress');
        const progressBar = document.getElementById('uploadProgressBar');
        const statusText = document.getElementById('uploadStatus');
        progressContainer.style.display = 'block';

        const grid = document.getElementById('grid');
        const maxOrder = window.GALLERY_DATA.photos.reduce((max, p) =>
          Math.max(max, p.order || 0), -1);

        for (let i = 0; i < files.length; i++) {
          const file = files[i];

          // Update progress
          const percent = ((i + 1) / files.length) * 100;
          progressBar.style.width = percent + '%';
          statusText.textContent = `${i + 1} of ${files.length} photos`;

          // Read file as data URL
          const dataUrl = await readFileAsDataURL(file);

          // Generate unique filename
          const timestamp = Date.now() + i;
          const newFilename = `photo_${timestamp}_${file.name.replace(/[^a-zA-Z0-9.]/g, '_')}`;

          // Create new photo object
          const newPhoto = {
            filename: newFilename,
            location: '',
            day: null,
            title: file.name.replace(/\.[^/.]+$/, ''), // Use filename without extension as title
            notes: '',
            faces: [],
            back_of_pic: '',
            mood: '',
            emoji: 'üì∑',
            favorite: false,
            color: 'var(--c1)',
            aspect_ratio: '16:9',
            cloudUrl: '',
            backupUrl: '',
            localPath: dataUrl, // Use data URL for local preview
            size: file.size,
            modified: new Date(file.lastModified).toISOString(),
            caption: file.name.replace(/\.[^/.]+$/, ''),
            'sub-point-name': '',
            'sub-point-position': '',
            'sub-point-row': 0,
            'sub-point-col': 0,
            'sub-point-x': 0,
            'sub-point-y': 0,
            order: maxOrder + i + 1,
            'sub-points': [],
            waypointType: 'rest-stop',
            restStopInfo: '',
            infoDetails: '',
            grouperDesc: '',
            infoTerms: []
          };

          // Auto-apply current perspective if one is selected
          if (currentPerspective) {
            newPhoto.photoPerspective = currentPerspective;
          }

          // Add to data structure
          window.GALLERY_DATA.photos.push(newPhoto);

          // Render new card
          const newCard = cardFor(newPhoto);
          newCard.draggable = true;

          // Make caption editable
          const caption = newCard.querySelector('.caption');
          if (caption) {
            caption.contentEditable = 'true';
            caption.style.outline = '1px dashed rgba(0,0,0,.3)';
          }

          // Keep edit fields collapsed for multi-upload (easier to reorder)
          // User can click "Show Details" button to expand individual cards

          grid.appendChild(newCard);

          // Small delay between cards for visual feedback
          await new Promise(resolve => setTimeout(resolve, 100));
        }

        // Hide progress bar
        setTimeout(() => {
          progressContainer.style.display = 'none';
          progressBar.style.width = '0%';
        }, 1000);

        // Clear file input
        event.target.value = '';

        console.log(`üì∑ Created ${files.length} new photos`);

        // Scroll to first new card
        const firstNewCard = grid.children[grid.children.length - files.length];
        if (firstNewCard) {
          firstNewCard.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }
      }

      // Helper function to read file as data URL
      function readFileAsDataURL(file) {
        return new Promise((resolve, reject) => {
          const reader = new FileReader();
          reader.onload = (e) => resolve(e.target.result);
          reader.onerror = reject;
          reader.readAsDataURL(file);
        });
      }

      async function loadData() {
        try {
          const res = await fetch('../gallery-data.json', { cache: 'no-store' });
          const data = await res.json();
          window.GALLERY_DATA = data; // Store globally for waypoint functions
          return data;
        } catch {
          window.GALLERY_DATA = { photos: [] };
          return { photos: [] };
        }
      }

      function cardFor(photo) {
        const div = document.createElement('div');
        div.className = 'card';
        div.dataset.filename = photo.filename || '';

        // Render waypoint dots HTML with perspective colors and similarity shading
        const waypointDotsHTML = (photo['sub-points'] || []).map((wp, idx) => {
          // Get perspective color if available
          let bgColor = '#ff6600'; // Default orange
          if (wp.perspective && perspectives.length > 0) {
            const perspective = perspectives.find(p => p.name === wp.perspective);
            if (perspective) {
              bgColor = perspective.color;

              // Apply similarity shading (0 = darkest shade, 1 = brightest tint)
              if (wp.similarity !== undefined) {
                // similarity 0-1 scale
                // Low similarity (0) = add black (darken)
                // High similarity (1) = add white (lighten)
                if (wp.similarity < 0.5) {
                  // Shade it (add black) - 0 = very dark, 0.5 = pure color
                  const darkenAmount = (0.5 - wp.similarity) * 0.8; // 0 to 0.4
                  bgColor = adjustColorShade(bgColor, -darkenAmount);
                } else if (wp.similarity > 0.5) {
                  // Tint it (add white) - 0.5 = pure color, 1 = very light
                  const lightenAmount = (wp.similarity - 0.5) * 0.8; // 0 to 0.4
                  bgColor = adjustColorShade(bgColor, lightenAmount);
                }
                // similarity === 0.5 = pure color (no adjustment)
              }
            }
          }

          return `
          <div class="card-waypoint-dot"
               style="left: ${wp.xPercent}%; top: ${wp.yPercent}%; background: ${bgColor};"
               onclick="openWaypointCardPopup(this, '${photo.filename}', ${idx}, event)"
               data-waypoint-index="${idx}">
            ${wp.emoji || 'üìç'}
          </div>
        `;
        }).join('');

        div.innerHTML = `
        <div class="photo-container" onclick="addWaypointToCard(event, this)" style="cursor: crosshair;">
          <img src="${photo.cloudUrl || photo.localPath}" alt="${photo.title || photo.filename}">
          <div class="replace-photo-icon" onclick="event.stopPropagation(); replacePhotoForCard(this)" title="Replace Photo">üîÑ</div>
          ${waypointDotsHTML}
        </div>
        <div class="info">
          <div class="caption">${photo.title || photo.filename}</div>
          <div class="location">${photo.location || ''} Day ${photo.day || 0}</div>
          <button class="toggle-fields-btn" onclick="togglePhotoFields(this)" style="width: 100%; padding: 8px; margin: 8px 0; background: #f8f9fa; border: 1px solid #dee2e6; border-radius: 4px; cursor: pointer; font-size: 13px; font-weight: 600; color: #495057; transition: all 0.2s;">
            <span class="toggle-icon">‚ñº</span> Show Details
          </button>
          <div class="edit-fields" style="display: none;">

            <!-- WAYPOINTS ON THIS PHOTO (moved UP) -->
            <div class="field-group" style="background: #f0f8ff; padding: 12px; border-radius: 8px; border: 2px solid #667eea; margin-bottom: 16px;">
              <label style="color: #667eea; font-weight: bold; font-size: 14px;">üìç Waypoints on This Photo</label>
              <div class="waypoint-summary" data-filename="${photo.filename || ''}" style="font-size: 13px; color: #666; margin-top: 8px;">
                <div class="waypoint-count" style="margin-bottom: 8px;">
                  ${(photo['sub-points'] || []).length} waypoint(s)
                </div>
                <div class="waypoint-list-mini" style="max-height: 200px; overflow-y: auto;">
                  ${(photo['sub-points'] || []).map((wp, idx) => {
          const typeIcon = wp.type === 'info' ? 'üìÑ' : wp.type === 'grouper' ? 'üìÅ' : 'üõë';
          const perspectiveBadge = wp.perspective ? `<span style="background: #667eea; color: white; padding: 2px 6px; border-radius: 3px; font-size: 10px; margin-left: 4px;">${wp.perspective}</span>` : '';
          return `
                    <div style="background: white; padding: 8px 10px; margin-bottom: 6px; border-radius: 4px; border: 1px solid #dee2e6; cursor: pointer;" onclick="openWaypointCardPopup(document.querySelector('[data-filename=&quot;${photo.filename}&quot;] [data-waypoint-index=&quot;${idx}&quot;]'), '${photo.filename}', ${idx}, event)">
                      <div style="font-weight: 600;">${typeIcon} ${wp.title || wp.name || 'Untitled'}${perspectiveBadge}</div>
                      ${wp.info ? `<div style="font-size: 11px; color: #666; margin-top: 4px;">${wp.info.substring(0, 60)}${wp.info.length > 60 ? '...' : ''}</div>` : ''}
                      <div style="font-size: 10px; color: #999; margin-top: 2px;">Type: ${wp.type || 'rest-stop'}</div>
                    </div>
                  `;
        }).join('') || '<div style="color: #999; font-style: italic; padding: 8px;">No waypoints yet. Click on photo to add.</div>'}
                </div>
              </div>
            </div>

            <!-- ASSET INFO (photo-level fallback data) -->
            <div class="field-group" style="background: #fff9e6; padding: 12px; border-radius: 8px; border: 2px solid #ffc107; margin-bottom: 16px;">
              <label style="color: #f57c00; font-weight: bold; font-size: 14px;">üì∑ Asset Info (Fallback)</label>
              <small style="display: block; color: #999; font-size: 11px; margin-bottom: 12px;">Used when no waypoints are set</small>
              ${renderWaypointAssetForm(photo, 0, photo.filename, 'asset')}
            </div>

            <!-- BACK OF PHOTO (admin notes) -->
            <div class="field-group">
              <label>Back of Photo <span style="color: #dc3545; font-size: 12px;">internal - no public notes</span></label>
              <textarea class="ef-back" placeholder="Admin notes (not displayed to viewers)...">${photo.back_of_pic || ''}</textarea>
            </div>

            <div class="half">
              <div>
                <label>Emoji</label>
                <input class="ef-emoji" value="${photo.emoji || ''}" placeholder="üèõÔ∏è">
                <div class="emoji-picker">
                  <button type="button" class="emoji-picker-toggle" onclick="toggleEmojiPicker(this)">Choose Emoji</button>
                  <div class="emoji-categories">
                    <div class="emoji-category">
                      <div class="emoji-category-label">Travel By</div>
                      <div class="emoji-buttons">
                        <button type="button" class="emoji-btn" onclick="selectEmoji(this, '‚úàÔ∏è')">‚úàÔ∏è</button>
                        <button type="button" class="emoji-btn" onclick="selectEmoji(this, 'üöó')">üöó</button>
                        <button type="button" class="emoji-btn" onclick="selectEmoji(this, 'üöå')">üöå</button>
                        <button type="button" class="emoji-btn" onclick="selectEmoji(this, 'üöÇ')">üöÇ</button>
                        <button type="button" class="emoji-btn" onclick="selectEmoji(this, '‚õµ')">‚õµ</button>
                        <button type="button" class="emoji-btn" onclick="selectEmoji(this, 'üö¢')">üö¢</button>
                        <button type="button" class="emoji-btn" onclick="selectEmoji(this, 'üöÅ')">üöÅ</button>
                        <button type="button" class="emoji-btn" onclick="selectEmoji(this, 'üêó')">üêó</button>
                      </div>
                    </div>
                    <div class="emoji-category">
                      <div class="emoji-category-label">What We Saw</div>
                      <div class="emoji-buttons">
                        <button type="button" class="emoji-btn" onclick="selectEmoji(this, 'üèõÔ∏è')">üèõÔ∏è</button>
                        <button type="button" class="emoji-btn" onclick="selectEmoji(this, 'üè∞')">üè∞</button>
                        <button type="button" class="emoji-btn" onclick="selectEmoji(this, '‚õ™')">‚õ™</button>
                        <button type="button" class="emoji-btn" onclick="selectEmoji(this, 'üóø')">üóø</button>
                        <button type="button" class="emoji-btn" onclick="selectEmoji(this, 'üåâ')">üåâ</button>
                        <button type="button" class="emoji-btn" onclick="selectEmoji(this, 'üèîÔ∏è')">üèîÔ∏è</button>
                        <button type="button" class="emoji-btn" onclick="selectEmoji(this, 'üåÑ')">üåÑ</button>
                        <button type="button" class="emoji-btn" onclick="selectEmoji(this, 'üèñÔ∏è')">üèñÔ∏è</button>
                        <button type="button" class="emoji-btn" onclick="selectEmoji(this, 'üåä')">üåä</button>
                        <button type="button" class="emoji-btn" onclick="selectEmoji(this, 'üå≥')">üå≥</button>
                        <button type="button" class="emoji-btn" onclick="selectEmoji(this, 'üé≠')">üé≠</button>
                        <button type="button" class="emoji-btn" onclick="selectEmoji(this, 'üé®')">üé®</button>
                      </div>
                    </div>
                    <div class="emoji-category">
                      <div class="emoji-category-label">Activities</div>
                      <div class="emoji-buttons">
                        <button type="button" class="emoji-btn" onclick="selectEmoji(this, 'üö∂')">üö∂</button>
                        <button type="button" class="emoji-btn" onclick="selectEmoji(this, 'üèä')">üèä</button>
                        <button type="button" class="emoji-btn" onclick="selectEmoji(this, 'ü•æ')">ü•æ</button>
                        <button type="button" class="emoji-btn" onclick="selectEmoji(this, 'üßó')">üßó</button>
                        <button type="button" class="emoji-btn" onclick="selectEmoji(this, 'ü§ø')">ü§ø</button>
                        <button type="button" class="emoji-btn" onclick="selectEmoji(this, 'üì∏')">üì∏</button>
                        <button type="button" class="emoji-btn" onclick="selectEmoji(this, 'üõçÔ∏è')">üõçÔ∏è</button>
                        <button type="button" class="emoji-btn" onclick="selectEmoji(this, 'üé™')">üé™</button>
                      </div>
                    </div>
                    <div class="emoji-category">
                      <div class="emoji-category-label">Food</div>
                      <div class="emoji-buttons">
                        <button type="button" class="emoji-btn" onclick="selectEmoji(this, 'üçï')">üçï</button>
                        <button type="button" class="emoji-btn" onclick="selectEmoji(this, 'üçù')">üçù</button>
                        <button type="button" class="emoji-btn" onclick="selectEmoji(this, 'ü•ñ')">ü•ñ</button>
                        <button type="button" class="emoji-btn" onclick="selectEmoji(this, 'üç∑')">üç∑</button>
                        <button type="button" class="emoji-btn" onclick="selectEmoji(this, '‚òï')">‚òï</button>
                        <button type="button" class="emoji-btn" onclick="selectEmoji(this, 'üç∫')">üç∫</button>
                        <button type="button" class="emoji-btn" onclick="selectEmoji(this, 'ü•ê')">ü•ê</button>
                        <button type="button" class="emoji-btn" onclick="selectEmoji(this, 'üßÄ')">üßÄ</button>
                        <button type="button" class="emoji-btn" onclick="selectEmoji(this, 'üç£')">üç£</button>
                        <button type="button" class="emoji-btn" onclick="selectEmoji(this, 'üçú')">üçú</button>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
              <div>
                <label>Favorite</label>
                <input class="ef-fav" type="checkbox" ${photo.favorite ? 'checked' : ''}>
              </div>
            </div>

            <!-- DELETE PHOTO BUTTON -->
            <div style="margin-top: 20px; padding-top: 16px; border-top: 1px solid #ddd;">
              <button class="delete-photo-btn" style="background: #dc3545; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer; width: 100%;" onclick="deletePhoto('${photo.filename}')">üóëÔ∏è Delete Photo</button>
            </div>
          </div>
        </div>`;

        return div;
      }

      // Add waypoint to card photo when clicking on the photo
      function addWaypointToCard(event, photoContainer) {
        // Don't add waypoint if clicking on replace icon or existing waypoint
        if (event.target.classList.contains('replace-photo-icon') ||
          event.target.classList.contains('card-waypoint-dot')) {
          return;
        }

        const card = photoContainer.closest('.card');
        const filename = card.dataset.filename;
        const img = photoContainer.querySelector('img');
        const rect = img.getBoundingClientRect();

        // Calculate click position as percentage
        const x = event.clientX - rect.left;
        const y = event.clientY - rect.top;
        const xPercent = (x / rect.width) * 100;
        const yPercent = (y / rect.height) * 100;

        // Get current photo data
        const data = window.GALLERY_DATA || { photos: [] };
        const photo = data.photos.find(p => p.filename === filename);

        if (!photo) {
          alert('‚ùå Could not find photo data');
          return;
        }

        // Initialize sub-points array if it doesn't exist
        if (!photo['sub-points']) {
          photo['sub-points'] = [];
        }

        // Create new waypoint with current perspective applied
        const newWaypoint = {
          name: `Waypoint ${photo['sub-points'].length + 1}`,
          title: `Waypoint ${photo['sub-points'].length + 1}`,
          xPercent: xPercent,
          yPercent: yPercent,
          emoji: 'üìç',
          linkedPhotoId: '',
          type: 'rest-stop',
          infoTerms: []
        };

        // Auto-apply current perspective if one is selected
        if (currentPerspective) {
          const perspective = perspectives.find(p => p.name === currentPerspective);
          if (perspective) {
            newWaypoint.perspective = perspective.name;
            newWaypoint.perspectiveDesc = perspective.desc;
            console.log(`‚ú® Auto-applied perspective: ${perspective.name}`);
          }
        }

        photo['sub-points'].push(newWaypoint);

        // Re-render the card to show the new waypoint
        const grid = document.getElementById('grid');
        const newCard = cardFor(photo);
        newCard.draggable = true;

        // Copy edit field values from old card
        const oldCard = card;
        newCard.querySelector('.caption').contentEditable = 'true';
        newCard.querySelector('.caption').style.outline = '1px dashed rgba(0,0,0,.3)';
        newCard.querySelector('.edit-fields').style.display = 'block';

        // Replace old card with new card
        grid.replaceChild(newCard, oldCard);

        // Open popup for the new waypoint
        const newWaypointIndex = photo['sub-points'].length - 1;
        const newDot = newCard.querySelector(`[data-waypoint-index="${newWaypointIndex}"]`);
        if (newDot) {
          setTimeout(() => openWaypointCardPopup(newDot, filename, newWaypointIndex), 100);
        }

        console.log('‚úÖ Added waypoint to', filename, 'at', xPercent.toFixed(1) + '%,', yPercent.toFixed(1) + '%');
      }

      // Open waypoint popup when clicking a waypoint dot
      let currentWaypointPopup = null;

      function openWaypointCardPopup(dotElement, filename, waypointIndex, event) {
        if (event) event.stopPropagation(); // Prevent adding new waypoint

        // Close any existing popup
        if (currentWaypointPopup) {
          currentWaypointPopup.remove();
          currentWaypointPopup = null;
        }

        // Get waypoint data
        const data = window.GALLERY_DATA || { photos: [] };
        const photo = data.photos.find(p => p.filename === filename);
        if (!photo || !photo['sub-points'] || !photo['sub-points'][waypointIndex]) {
          alert('‚ùå Waypoint not found');
          return;
        }

        const waypoint = photo['sub-points'][waypointIndex];

        // Create popup
        const popup = document.createElement('div');
        popup.className = 'waypoint-card-popup active';

        // Calculate absolute position on page using dot's percentage position
        const photoContainer = dotElement.closest('.photo-container');
        const containerRect = photoContainer.getBoundingClientRect();

        // Get dot's percentage position from its inline style
        const dotLeft = parseFloat(dotElement.style.left) / 100; // Convert % to decimal
        const dotTop = parseFloat(dotElement.style.top) / 100;

        // Calculate absolute position on page
        const dotPageX = containerRect.left + (containerRect.width * dotLeft);
        const dotPageY = containerRect.top + window.pageYOffset + (containerRect.height * dotTop);

        // Position popup below the dot, aligned to right edge of photo
        popup.style.position = 'absolute'; // Scrolls with page
        popup.style.right = `${window.innerWidth - containerRect.right}px`;
        popup.style.left = 'auto';
        popup.style.top = `${dotPageY + 20}px`; // 20px below the dot center

        // Use reusable form generator
        popup.innerHTML = renderWaypointAssetForm(waypoint, waypointIndex, filename, 'modal');

        // Add popup to body instead of card (so it's not clipped)
        document.body.appendChild(popup);
        currentWaypointPopup = popup;

        // Stop clicks inside popup from bubbling up (prevents closing)
        popup.addEventListener('click', (e) => {
          e.stopPropagation();
        });

        // Populate link dropdown with all photos
        populateWaypointLinkDropdown(filename, waypointIndex, waypoint.linkedPhotoId);

        console.log('üìç Waypoint popup opened for', filename, 'waypoint', waypointIndex);
      }

      function populateWaypointLinkDropdown(currentFilename, waypointIndex, selectedLink) {
        const dropdown = document.getElementById(`waypoint-${waypointIndex}-link`);
        if (!dropdown) {
          console.warn('‚ö†Ô∏è Dropdown not found:', `waypoint-${waypointIndex}-link`);
          return;
        }

        const data = window.GALLERY_DATA || { photos: [] };
        const photos = data.photos || [];

        dropdown.innerHTML = '<option value="">None - No link</option>';

        // Add all photos (except current one)
        photos.forEach(photo => {
          if (photo.filename !== currentFilename) {
            const option = document.createElement('option');
            option.value = photo.filename;
            option.textContent = photo.title || photo.filename;
            if (photo.filename === selectedLink) {
              option.selected = true;
            }
            dropdown.appendChild(option);
          }
        });

        console.log('üìã Populated link dropdown with', photos.length - 1, 'photos (excluding current)');
      }

      function updateWaypointLink(filename, waypointIndex, linkedPhotoId) {
        const data = window.GALLERY_DATA || { photos: [] };
        const photo = data.photos.find(p => p.filename === filename);
        if (photo && photo['sub-points'] && photo['sub-points'][waypointIndex]) {
          photo['sub-points'][waypointIndex].linkedPhotoId = linkedPhotoId;
          console.log('‚úÖ Updated waypoint link:', linkedPhotoId);
        }
      }

      function updateWaypointEmoji(filename, waypointIndex, emoji) {
        const data = window.GALLERY_DATA || { photos: [] };
        const photo = data.photos.find(p => p.filename === filename);
        if (photo && photo['sub-points'] && photo['sub-points'][waypointIndex]) {
          photo['sub-points'][waypointIndex].emoji = emoji;

          // Update the dot's emoji
          const card = document.querySelector(`[data-filename="${filename}"]`);
          if (card) {
            const dot = card.querySelector(`[data-waypoint-index="${waypointIndex}"]`);
            if (dot) {
              dot.textContent = emoji;
            }
          }

          console.log('‚úÖ Updated waypoint emoji:', emoji);
        }
      }

      function saveWaypointChanges(filename, waypointIndex) {
        // Show saving feedback
        const saveBtn = document.querySelector('.save-waypoint-btn');
        if (saveBtn) {
          saveBtn.textContent = 'üíæ Saving...';
          saveBtn.disabled = true;
          saveBtn.style.opacity = '0.6';
        }

        // Get values from popup inputs
        const typeSelect = document.getElementById(`waypoint-${waypointIndex}-type`);
        const titleInput = document.getElementById(`waypoint-${waypointIndex}-title`);
        const infoTextarea = document.getElementById(`waypoint-${waypointIndex}-info`);
        const perspectiveSelect = document.getElementById(`waypoint-${waypointIndex}-perspective`);
        const linkSelect = document.getElementById(`waypoint-${waypointIndex}-link`);
        const groupersInput = document.getElementById(`waypoint-${waypointIndex}-groupers`);
        const infoTermsInput = document.getElementById(`waypoint-${waypointIndex}-infoTerms`);

        const data = window.GALLERY_DATA || { photos: [] };
        const photo = data.photos.find(p => p.filename === filename);

        if (!photo || !photo['sub-points'] || !photo['sub-points'][waypointIndex]) {
          alert('‚ùå Waypoint not found');
          return;
        }

        const waypoint = photo['sub-points'][waypointIndex];

        // Update type
        if (typeSelect) {
          waypoint.type = typeSelect.value;
          console.log('‚úÖ Updated waypoint type:', typeSelect.value);
        }

        // Update title
        if (titleInput) {
          waypoint.title = titleInput.value;
          waypoint.name = titleInput.value; // Keep both for compatibility
          console.log('‚úÖ Updated waypoint title:', titleInput.value);
        }

        // Update info/description
        if (infoTextarea) {
          waypoint.info = infoTextarea.value;
          console.log('‚úÖ Updated waypoint info:', infoTextarea.value);
        }

        // Update perspective
        if (perspectiveSelect) {
          const selectedPerspective = perspectiveSelect.value;
          if (selectedPerspective) {
            const perspective = perspectives.find(p => p.name === selectedPerspective);
            if (perspective) {
              waypoint.perspective = perspective.name;
              waypoint.perspectiveDesc = perspective.desc;
              console.log('‚úÖ Updated waypoint perspective:', perspective.name);
            }
          } else {
            // Clear perspective if "No Perspective" selected
            delete waypoint.perspective;
            delete waypoint.perspectiveDesc;
            console.log('‚úÖ Cleared waypoint perspective');
          }
        }

        // Update link
        if (linkSelect) {
          waypoint.linkedPhotoId = linkSelect.value.trim();
          console.log('‚úÖ Updated waypoint link:', linkSelect.value.trim());
        }

        // Update groupers
        if (groupersInput) {
          const groupers = groupersInput.value.split(',').map(g => g.trim()).filter(g => g);
          waypoint.groupers = groupers;
          console.log('‚úÖ Updated waypoint groupers:', groupers);
        }

        // Update info terms
        if (infoTermsInput) {
          const terms = infoTermsInput.value.split(',').map(t => t.trim()).filter(t => t);
          waypoint.infoTerms = terms;
          console.log('‚úÖ Updated waypoint info terms:', terms);
        }

        // Note: similarity is auto-calculated on save, not manually set
        // Note: emoji removed from waypoint modal per requirements

        // Show success feedback
        if (saveBtn) {
          saveBtn.textContent = '‚úÖ Saved!';
          saveBtn.style.background = '#28a745';
        }

        // Update the waypoint display box
        setTimeout(() => {
          updateWaypointDisplayBox(filename);

          // Close popup after brief delay
          setTimeout(() => {
            if (currentWaypointPopup) {
              currentWaypointPopup.remove();
              currentWaypointPopup = null;
            }
          }, 500);
        }, 300);

        console.log('‚úÖ Saved waypoint changes for', filename);
      }

      function updateWaypointDisplayBox(filename) {
        // Find the waypoint summary element for this photo
        const waypointSummary = document.querySelector(`.waypoint-summary[data-filename="${filename}"]`);
        if (!waypointSummary) {
          console.warn('Waypoint summary box not found for', filename);
          return;
        }

        const data = window.GALLERY_DATA || { photos: [] };
        const photo = data.photos.find(p => p.filename === filename);
        if (!photo) {
          console.warn('Photo not found:', filename);
          return;
        }

        // Update the waypoint list
        const waypointList = waypointSummary.querySelector('.waypoint-list-mini');
        if (waypointList) {
          const waypoints = photo['sub-points'] || [];
          waypointList.innerHTML = waypoints.map(wp => `
          <div style="background: white; padding: 6px 10px; margin-bottom: 6px; border-radius: 4px; border: 1px solid #dee2e6;">
            <div style="font-weight: 600;">${wp.emoji || 'üìç'} ${wp.title || wp.name || 'Untitled'}</div>
            <div style="font-size: 11px; color: #999;">Type: ${wp.type || 'rest-stop'}</div>
            ${wp.linkedPhotoId ? `<div style="font-size: 11px; color: #28a745;">üîó Links to: ${wp.linkedPhotoId}</div>` : ''}
            ${wp.infoTerms && wp.infoTerms.length > 0 ? `<div style="font-size: 11px; color: #667eea;">Tags: ${wp.infoTerms.join(', ')}</div>` : ''}
          </div>
        `).join('') || '<div style="color: #999; font-style: italic;">No waypoints yet. Click "Edit Photo Locations" to add.</div>';

          // Update count
          const countElement = waypointSummary.querySelector('.waypoint-count');
          if (countElement) {
            countElement.textContent = `${waypoints.length} waypoint(s)`;
          }

          console.log('‚úÖ Updated waypoint display box for', filename);
        }
      }

      function removeWaypoint(filename, waypointIndex) {
        if (!confirm('Delete this waypoint?')) return;

        const data = window.GALLERY_DATA || { photos: [] };
        const photo = data.photos.find(p => p.filename === filename);
        if (photo && photo['sub-points']) {
          photo['sub-points'].splice(waypointIndex, 1);

          // Re-render the card
          const grid = document.getElementById('grid');
          const oldCard = document.querySelector(`[data-filename="${filename}"]`);
          if (oldCard) {
            const newCard = cardFor(photo);
            newCard.draggable = true;
            newCard.querySelector('.caption').contentEditable = 'true';
            newCard.querySelector('.caption').style.outline = '1px dashed rgba(0,0,0,.3)';
            newCard.querySelector('.edit-fields').style.display = 'block';
            grid.replaceChild(newCard, oldCard);
          }

          // Close popup
          if (currentWaypointPopup) {
            currentWaypointPopup.remove();
            currentWaypointPopup = null;
          }

          console.log('‚úÖ Removed waypoint from', filename);
        }
      }

      function textCardFor(textBlock) {
        const div = document.createElement('div');
        div.className = 'card text-card';
        div.dataset.textId = textBlock.id || '';
        div.dataset.type = 'text';
        div.innerHTML = `
        <div class="text-preview" style="padding: 2rem; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; min-height: 150px; display: flex; align-items: center; justify-content: center; text-align: ${textBlock.textAlign || 'left'}; font-size: ${textBlock.fontSize || '16px'};">
          ${textBlock.content || 'Click to edit text...'}
        </div>
        <div class="info">
          <div class="caption">üìù Text Block</div>
          <div class="location">Text Content</div>
          <div class="edit-fields">
            <div class="field-group">
              <label>Content</label>
              <textarea class="ef-text-content" rows="4" placeholder="Enter your text here...">${textBlock.content || ''}</textarea>
            </div>

            <div class="field-group">
              <label>Font Size</label>
              <select class="ef-text-fontSize">
                <option value="14px" ${textBlock.fontSize === '14px' ? 'selected' : ''}>Small</option>
                <option value="16px" ${textBlock.fontSize === '16px' || !textBlock.fontSize ? 'selected' : ''}>Medium</option>
                <option value="20px" ${textBlock.fontSize === '20px' ? 'selected' : ''}>Large</option>
                <option value="24px" ${textBlock.fontSize === '24px' ? 'selected' : ''}>Extra Large</option>
              </select>
            </div>

            <div class="field-group">
              <label>Text Align</label>
              <select class="ef-text-textAlign">
                <option value="left" ${textBlock.textAlign === 'left' || !textBlock.textAlign ? 'selected' : ''}>Left</option>
                <option value="center" ${textBlock.textAlign === 'center' ? 'selected' : ''}>Center</option>
                <option value="right" ${textBlock.textAlign === 'right' ? 'selected' : ''}>Right</option>
              </select>
            </div>

            <div class="field-group">
              <button class="delete-text-btn" style="background: #dc3545; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer;" onclick="deleteTextBlock(this)">üóëÔ∏è Delete Text Block</button>
            </div>
          </div>
        </div>`;

        return div;
      }

      async function saveCountrySelection(country) {
        const dev_project = (location.hostname.split('.')[0] || '').toLowerCase();
        try {
          console.log('üåç Saving overall-point:', country);
          const resp = await fetch(`/api/gallery/${dev_project}/trip/update`, {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              trip: { "overall-point": country }
            })
          });
          const result = await resp.json();
          console.log('‚úÖ Overall-point save result:', result);
          if (!result.success) throw new Error(result.error || 'Failed to save overall-point');
          return true;
        } catch (e) {
          console.error('Failed to save country:', e);
          return false;
        }
      }

      async function init() {
        const data = await loadData();
        initializePerspectives(); // Initialize perspectives panel
        bindTripInfo(data);

        // Load saved sub-points (locations) from trip
        if (data.trip && data.trip["sub-points"] && Array.isArray(data.trip["sub-points"])) {
          currentLocations = data.trip["sub-points"];
          console.log('üìç Loaded sub-points from gallery-data.json:', currentLocations);
        } else {
          currentLocations = [];
          console.log('‚ö†Ô∏è No sub-points in gallery-data.json');
        }

        const grid = document.getElementById('grid');

        // Load photos and text blocks, sorted by order
        // Filter out template photos (they'll be shown separately via "+ Add Photo" button)
        const photos = (data.photos || [])
          .filter(p => !p.isTemplate)
          .map(p => ({ ...p, type: 'photo' }));
        const textBlocks = (data.trip && data.trip.textBlocks) || [];

        console.log('üîç RAW DATA:', {
          photosFromJSON: data.photos?.length || 0,
          textBlocksFromJSON: data.trip?.textBlocks?.length || 0,
          textBlocksRaw: data.trip?.textBlocks
        });

        // Combine and sort by order (use 999999 for items without order to push them to end)
        const allContent = [...photos, ...textBlocks].sort((a, b) => {
          const orderA = (a.order !== undefined && a.order !== null) ? a.order : 999999;
          const orderB = (b.order !== undefined && b.order !== null) ? b.order : 999999;
          return orderA - orderB;
        });

        console.log('üì¶ Combined content:', {
          photos: photos.length,
          textBlocks: textBlocks.length,
          total: allContent.length,
          contentByType: allContent.map(i => i.type),
          orderValues: allContent.map(i => ({
            type: i.type,
            id: i.id || i.filename,
            order: i.order
          }))
        });

        // Render all content in order
        allContent.forEach(item => {
          if (item.type === 'text') {
            console.log('‚úÖ Rendering text block:', item.id);
            grid.appendChild(textCardFor(item));
          } else {
            grid.appendChild(cardFor(item));
          }
        });

        // Standardize row heights after images load
        standardizeRowHeights();

        // Show display map with location dots if not in edit mode
        const params = new URLSearchParams(location.search);
        console.log('üîç Edit mode check:', {
          editParam: params.get('edit'),
          shouldShowEditor: !!params.get('edit')
        });

        if (!params.get('edit')) {
          console.log('‚ùå No edit param - showing display map');
          showDisplayMap(data);
          return;
        }

        console.log('‚úÖ Edit mode active - showing editor');

        // Load config from accid_dropper to check enabled modules
        let adminModules = {};
        try {
          const dropperResponse = await fetch('../accid_dropper.json');
          if (dropperResponse.ok) {
            const dropper = await dropperResponse.json();
            adminModules = dropper.admin_modules || {};
            console.log('üì¶ Loaded admin modules config:', adminModules);
          }
        } catch (e) {
          console.log('‚ö†Ô∏è No dropper config found - using defaults');
        }

        // Check if modules are enabled
        const imgbbEnabled = adminModules['imgbb-uploader']?.enabled !== false;
        const dropboxEnabled = adminModules['dropbox-connector']?.enabled !== false;

        const bar = document.createElement('div');
        bar.style.cssText = 'position:fixed;top:0px;left:10px;z-index:9999;background:rgba(17,17,17,.85);color:#fff;padding:10px 14px;border-bottom-right-radius: 16px;border-bottom-left-radius: 17px;display:flex;gap:12px;align-items:center;font:14px/1.2 -apple-system,BlinkMacSystemFont,sans-serif; width: 100%; max-width: 94vw; box-shadow:0 4px 12px rgba(0,0,0,.25)';
        bar.innerHTML = `<strong>TUTORIAL EDITOR</strong> ${dropboxEnabled ? '<button id="dropbox-update" class="editor-btn editor-btn-danger">üìÅ Import Images from Dropbox</button>' : ''} <button id="edit-trip" class="editor-btn editor-btn-purple">‚úçÔ∏è Edit Title &amp; Subtitle</button> <button id="add-text-block" class="editor-btn" style="background:#17a2b8;">üìù Add Text Block</button><button id="accid-back-to-project-view" class="editor-btn editor-btn-gray editor-btn-large">üéõÔ∏è Back to Project Dashboard</button> <button id="accid-save" class="editor-btn editor-btn-success editor-btn-xl">üîí  Save All Edits</button>`;
        document.body.appendChild(bar);

        // Bind title/subtitle/tags from trip
        function bindTripInfo(data) {
          try {
            const t = document.getElementById('galleryTitle');
            const s = document.getElementById('gallerySubtitle');
            const g = document.getElementById('galleryTags');
            const metadata = (data && data.metadata) || {};
            if (t) t.textContent = metadata.title || 'Tutorial Editor';
            if (s) s.textContent = metadata.subtitle || '';
            if (g) {
              // For tutorials, we display source instead of travelers/tags
              g.textContent = metadata.source ? `Source: ${metadata.source}` : '';
            }
          } catch (e) { }
        }






        const dropboxBtn = document.getElementById('dropbox-update');
        if (dropboxBtn) {
          dropboxBtn.addEventListener('click', () => {
            showDropboxFolderSelector();
          });
        }

        // ImgBB Upload button - DISABLED FOR TUTORIAL MODE
        // const imgbbBtn = document.getElementById('imgbb-upload');
        // if (imgbbBtn && window.accidImageUploader) {
        //   imgbbBtn.addEventListener('click', () => {
        //     window.accidImageUploader.show({
        //       allowDropbox: false, // Just ImgBB and direct URL for now
        //       onSelect: (imageUrl) => {
        //         console.log('üì§ Image uploaded:', imageUrl);
        //         // Add new card to gallery with the uploaded image
        //         addGalleryCard(imageUrl);
        //       }
        //     });
        //   });
        // }

        // Function to add a new gallery card with uploaded image
        function addGalleryCard(imageUrl) {
          const grid = document.querySelector('.grid');
          if (!grid) {
            console.error('Grid not found');
            return;
          }

          // Create photo object with ImgBB URL
          const newPhoto = {
            cloudUrl: imageUrl,
            filename: `imgbb-${Date.now()}.jpg`,
            title: 'New Photo',
            location: '',
            day: 0,
            notes: '',
            back_of_pic: '',
            emoji: 'üì∏',
            'sub-point-name': ''
          };

          // Use existing cardFor function to create the card
          const newCard = cardFor(newPhoto);

          // Make it editable
          newCard.draggable = true;
          newCard.querySelector('.caption').contentEditable = 'true';
          newCard.querySelector('.caption').style.outline = '1px dashed rgba(0,0,0,.3)';
          newCard.querySelector('.edit-fields').style.display = 'block';

          // Attach drag handlers
          attachDragHandlers(newCard);

          // Add to grid
          grid.appendChild(newCard);

          // Scroll to new card
          newCard.scrollIntoView({ behavior: 'smooth', block: 'center' });

          console.log('‚úÖ Gallery card added:', newPhoto);
        }

        // Export button removed (was causing errors)

        // Captions editable
        document.querySelectorAll('.card .caption').forEach(el => { el.contentEditable = 'true'; el.style.outline = '1px dashed rgba(0,0,0,.3)'; });

        // Show edit fields in edit mode
        document.querySelectorAll('.card .edit-fields').forEach(el => { el.style.display = 'block'; });

        // Populate all location dropdowns after edit fields are shown
        setTimeout(() => {
          updateAllLocationDropdowns();
        }, 100);

        // Drag and reorder cards - function to attach handlers
        function attachDragHandlers(card) {
          card.draggable = true;
          card.addEventListener('dragstart', e => {
            const cards = Array.from(grid.querySelectorAll('.card'));
            e.dataTransfer.setData('text/plain', cards.indexOf(card));
            card.style.opacity = .5;
          });
          card.addEventListener('dragend', e => { card.style.opacity = ''; });
          card.addEventListener('dragover', e => e.preventDefault());
          card.addEventListener('drop', e => {
            e.preventDefault();
            const cards = Array.from(grid.querySelectorAll('.card'));
            const from = +e.dataTransfer.getData('text/plain');
            const to = cards.indexOf(card);
            if (from === to || from < 0) return;
            const moving = cards[from];
            if (from < to) grid.insertBefore(moving, cards[to].nextSibling);
            else grid.insertBefore(moving, cards[to]);
          });
        }

        // Attach drag handlers to all existing cards
        const cards = Array.from(grid.querySelectorAll('.card'));
        console.log('üîç DRAG ATTACH - Cards found:', {
          total: cards.length,
          types: cards.map(c => ({ type: c.dataset.type, textId: c.dataset.textId, filename: c.dataset.filename }))
        });
        cards.forEach(card => attachDragHandlers(card));

        // DIAGNOSTIC: Check text blocks after all initialization
        setTimeout(() => {
          const allCardsAfter = grid.querySelectorAll('.card');
          const textCardsAfter = grid.querySelectorAll('.card.text-card');
          const textCardsByType = Array.from(allCardsAfter).filter(c => c.dataset.type === 'text');

          console.log('üîç AFTER INIT - Text blocks status:', {
            totalCards: allCardsAfter.length,
            textCardsByClass: textCardsAfter.length,
            textCardsByDataType: textCardsByType.length,
            allCardTypes: Array.from(allCardsAfter).map(c => c.dataset.type),
            textCardDetails: Array.from(textCardsAfter).map(c => ({
              id: c.dataset.textId,
              display: window.getComputedStyle(c).display,
              visibility: window.getComputedStyle(c).visibility,
              opacity: window.getComputedStyle(c).opacity,
              width: c.offsetWidth,
              height: c.offsetHeight,
              inDOM: document.body.contains(c),
              parentIsGrid: c.parentElement === grid,
              hasEditFields: c.querySelector('.edit-fields') !== null,
              editFieldsDisplay: c.querySelector('.edit-fields')?.style.display || 'not found'
            }))
          });

          // Check if any cards were REMOVED during init
          console.log('üìä Card type breakdown:', {
            photos: Array.from(allCardsAfter).filter(c => c.dataset.type !== 'text').length,
            textBlocks: Array.from(allCardsAfter).filter(c => c.dataset.type === 'text').length
          });
        }, 500);

        // Overlay for Edit Gallery Info
        function openTripOverlay(data) {
          const metadata = (data && data.metadata) || {};
          const overlay = document.createElement('div');
          overlay.id = 'trip-overlay';
          overlay.style.cssText = 'position:fixed;inset:0;background:rgba(0,0,0,.5);display:flex;align-items:center;justify-content:center;z-index:10000;';
          overlay.innerHTML = `
          <div class="modal-content">
            <div style=\"display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;\">
              <strong>Edit Gallery Info</strong>
              <button id=\"trip-close\" style=\"background:#444;color:#fff;border:0;border-radius:6px;padding:4px 8px;cursor:pointer;\">‚úï</button>
            </div>
            <label>Title</label>
            <input id="trip-title" class="modal-input" value="${metadata.title || ''}">
            <label>Subtitle</label>
            <input id="trip-subtitle" class="modal-input" value="${metadata.subtitle || ''}">
            <label>Source (optional)</label>
            <input id="trip-source" class="modal-input" value="${metadata.source || ''}" placeholder="e.g., ifixit, manual, custom">
            <div style="margin-top:12px;padding:8px;background:rgba(255,165,0,0.1);border-radius:6px;font-size:12px;color:#ff9500;">
              ‚ÑπÔ∏è Changes will be saved when you click "Save All Edits" button
            </div>
          </div>`;
          document.body.appendChild(overlay);

          // Update metadata in memory when fields change
          const titleInput = overlay.querySelector('#trip-title');
          const subtitleInput = overlay.querySelector('#trip-subtitle');
          const sourceInput = overlay.querySelector('#trip-source');

          const updateMetadata = () => {
            if (!window.GALLERY_DATA) window.GALLERY_DATA = {};
            if (!window.GALLERY_DATA.metadata) window.GALLERY_DATA.metadata = {};
            window.GALLERY_DATA.metadata.title = titleInput.value.trim();
            window.GALLERY_DATA.metadata.subtitle = subtitleInput.value.trim();
            window.GALLERY_DATA.metadata.source = sourceInput.value.trim();
            bindTripInfo({ metadata: window.GALLERY_DATA.metadata });
          };

          titleInput.addEventListener('input', updateMetadata);
          subtitleInput.addEventListener('input', updateMetadata);
          sourceInput.addEventListener('input', updateMetadata);

          overlay.querySelector('#trip-close').onclick = () => overlay.remove();

          // Allow clicking outside to close
          overlay.onclick = (e) => {
            if (e.target === overlay) overlay.remove();
          };
        }

        const editTripBtn = document.getElementById('edit-trip');
        if (editTripBtn) editTripBtn.addEventListener('click', () => openTripOverlay(data));

        // Add Text Block button handler
        const addTextBlockBtn = document.getElementById('add-text-block');
        if (addTextBlockBtn) addTextBlockBtn.addEventListener('click', () => addTextBlock());

        // Helper to generate unique text block IDs
        function generateTextId() {
          return 'text-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
        }

        // Add a new text block to the grid
        function addTextBlock() {
          const newTextBlock = {
            id: generateTextId(),
            type: 'text',
            content: 'New Text Block - Click to edit',
            fontSize: '16px',
            textAlign: 'left'
          };

          const textCard = textCardFor(newTextBlock);

          // Attach drag handlers using the shared function
          attachDragHandlers(textCard);

          // Show edit fields for text cards
          const editFields = textCard.querySelector('.edit-fields');
          if (editFields) editFields.style.display = 'block';

          // Insert at beginning of grid (first position)
          grid.insertBefore(textCard, grid.firstChild);
          console.log('‚úÖ Text block added at beginning:', newTextBlock.id);
        }

        // Delete text block
        window.deleteTextBlock = function (button) {
          const card = button.closest('.card');
          if (confirm('Delete this text block?')) {
            card.remove();
            console.log('üóëÔ∏è Text block deleted');
          }
        };

        // Delete photo
        window.deletePhoto = function (filename) {
          if (!filename) {
            alert('‚ö†Ô∏è No filename provided');
            return;
          }

          // Find the photo in data
          const photo = window.GALLERY_DATA.photos.find(p => p.filename === filename);
          if (!photo) {
            alert('‚ö†Ô∏è Photo not found in data');
            return;
          }

          // Check if photo has waypoints - warn user
          const hasWaypoints = photo['sub-points'] && photo['sub-points'].length > 0;
          const confirmMessage = hasWaypoints
            ? `Delete this photo?\n\nWarning: This photo has ${photo['sub-points'].length} waypoint(s) that will also be deleted.`
            : 'Delete this photo?';

          if (confirm(confirmMessage)) {
            // Remove from data structure
            const index = window.GALLERY_DATA.photos.indexOf(photo);
            if (index > -1) {
              window.GALLERY_DATA.photos.splice(index, 1);
            }

            // Remove card from DOM
            const grid = document.getElementById('grid');
            const card = grid.querySelector(`[data-filename="${filename}"]`);
            if (card) {
              card.remove();
            }

            console.log('üóëÔ∏è Photo deleted:', filename);
          }
        };

        function collect() {
          const photos = [];
          const textBlocks = [];
          let orderIndex = 0;

          const allCards = grid.querySelectorAll('.card');
          console.log('üîç COLLECT - Found cards:', {
            total: allCards.length,
            types: Array.from(allCards).map(c => ({
              type: c.dataset.type,
              textId: c.dataset.textId,
              filename: c.dataset.filename
            }))
          });

          allCards.forEach(c => {
            const cardType = c.dataset.type;

            // Handle TEXT BLOCKS
            if (cardType === 'text') {
              const textId = c.dataset.textId || '';
              const content = c.querySelector('.ef-text-content');
              const fontSize = c.querySelector('.ef-text-fontSize');
              const textAlign = c.querySelector('.ef-text-textAlign');

              console.log('‚úÖ COLLECT - Found text block:', {
                textId,
                hasContent: !!content,
                hasFontSize: !!fontSize,
                hasTextAlign: !!textAlign
              });

              if (textId) {
                textBlocks.push({
                  id: textId,
                  type: 'text',
                  order: orderIndex++,
                  content: content ? content.value : '',
                  fontSize: fontSize ? fontSize.value : '16px',
                  textAlign: textAlign ? textAlign.value : 'left'
                });
              }
            }
            // Handle PHOTOS
            else {
              const data = window.GALLERY_DATA || { photos: [] };
              let fn = c.dataset.filename || '';
              if (!fn) {
                const img = c.querySelector('img');
                if (img) fn = (img.getAttribute('src') || '').split('/').pop().split('?')[0];
              }

              // Find existing photo data to preserve all fields
              const existingPhoto = data.photos.find(p => p.filename === fn);
              const photoData = existingPhoto ? { ...existingPhoto } : { filename: fn };

              // Update order
              photoData.order = orderIndex++;

              // Get current img src (might have been replaced)
              const img = c.querySelector('img');
              if (img && img.src) {
                photoData.cloudUrl = img.src;
              }

              // Update editable fields
              const cap = c.querySelector('.caption');
              if (cap) photoData.caption = cap.textContent.trim();

              const t = c.querySelector('.ef-title');
              if (t) photoData.title = t.value;

              const notes = c.querySelector('.ef-notes');
              if (notes) photoData.notes = notes.value;

              const back = c.querySelector('.ef-back');
              if (back) photoData.back_of_pic = back.value;

              const emoji = c.querySelector('.ef-emoji');
              if (emoji) photoData.emoji = emoji.value;

              const fav = c.querySelector('.ef-fav');
              if (fav) photoData.favorite = fav.checked;

              // Get photo perspective
              const photoPerspective = c.querySelector('.ef-photo-perspective');
              if (photoPerspective) {
                photoData.photoPerspective = photoPerspective.value || '';
              }

              // Get waypoint type from Asset Info dropdown (new form)
              const assetTypeSelect = c.querySelector('.ef-asset-type');
              if (assetTypeSelect) {
                photoData.waypointType = assetTypeSelect.value;
              }
              // Fallback: Get waypoint type from OLD radio buttons (if asset form not found)
              else {
                const waypointTypeRadio = c.querySelector(`input[name="waypoint-type-${fn}"]:checked`);
                if (waypointTypeRadio) {
                  photoData.waypointType = waypointTypeRadio.value;
                }
              }

              // Get waypoint type text fields
              const restStopInfo = c.querySelector('.ef-restStopInfo');
              if (restStopInfo) photoData.restStopInfo = restStopInfo.value;

              const infoDetails = c.querySelector('.ef-infoDetails');
              if (infoDetails) photoData.infoDetails = infoDetails.value;

              const grouperDesc = c.querySelector('.ef-grouperDesc');
              if (grouperDesc) photoData.grouperDesc = grouperDesc.value;

              // Get info terms
              const infoTermsInput = c.querySelector('.ef-info-terms');
              if (infoTermsInput) {
                const terms = infoTermsInput.value.split(',').map(t => t.trim()).filter(t => t);
                photoData.infoTerms = terms;
                console.log('üìã Collected info terms for', fn, ':', terms);
              } else {
                console.warn('‚ö†Ô∏è No info terms input found for', fn);
              }

              // Sub-points are already in photoData from window.GALLERY_DATA
              // They get updated live via addWaypointToCard, removeWaypoint, etc.

              if (fn) {
                console.log('‚úÖ Collected photo data:', fn, 'infoTerms:', photoData.infoTerms, 'waypointType:', photoData.waypointType);
                photos.push(photoData);
              }
            }
          });

          return { photos, textBlocks };
        }

        async function saveAll() {
          // Auto-calculate similarity spectrum for all waypoints
          const similarityCount = calculateSimilarities();
          if (similarityCount > 0) {
            console.log(`üé® Calculated similarity spectrum for ${similarityCount} waypoints`);
          }

          const dev_project = (location.hostname.split('.')[0] || '').toLowerCase();
          const { photos, textBlocks } = collect();

          console.log('üíæ SAVE ALL - Current state:', {
            currentCountry,
            currentLocations,
            currentMapImage,
            photos: photos.length,
            textBlocks: textBlocks.length
          });

          try {
            // Get metadata from window.GALLERY_DATA (updated by Edit Title & Subtitle modal)
            const metadata = (window.GALLERY_DATA && window.GALLERY_DATA.metadata) || {
              title: '',
              subtitle: '',
              source: '',
              created: new Date().toISOString().split('T')[0],
              gallery_id: dev_project
            };

            // Build complete data structure
            const completeData = {
              metadata: metadata,
              photos: photos,
              perspectives: perspectives,
              last_modified: new Date().toISOString()
            };

            // Test JSON serialization before sending
            try {
              JSON.stringify(completeData);
            } catch (jsonError) {
              console.error('‚ùå JSON stringify error:', jsonError);
              alert('Data contains invalid characters. Check for quotes in text fields.');
              return;
            }

            console.log('üíæ SAVE ALL - Detailed breakdown:', {
              photos: photos.length,
              perspectives: perspectives.length,
              perspectiveDetails: perspectives.map(p => ({ name: p.name, color: p.color })),
              waypointCount: photos.reduce((sum, p) => sum + (p['sub-points']?.length || 0), 0)
            });
            console.log('üíæ Saving complete data:', completeData);

            // Save to both dropper and blotter using the save endpoint
            const saveResp = await fetch(`/api/tutorial/${dev_project}/save`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify(completeData)
            });

            const result = await saveResp.json();
            console.log('‚úÖ Save result:', result);

            if (result.success) {
              // Update window.GALLERY_DATA with saved data
              window.GALLERY_DATA = completeData;

              bar.style.background = '#0f5132'; bar.style.color = '#d1e7dd'; bar.querySelector('#accid-save').textContent = 'Saved!';
              setTimeout(() => location.reload(), 600);
            } else {
              throw new Error(result.error || 'Save failed');
            }
          } catch (e) {
            console.error('‚ùå Save failed:', e);
            alert('Save failed: ' + e);
          }
        }

        document.getElementById('accid-save').addEventListener('click', saveAll);


        // Extract subdomain before ".localhost"
        const host = window.location.hostname; // e.g., "gallery12.localhost"
        const subdomain = host.split(".")[0];  // -> "gallery12"

        document.getElementById('accid-back-to-project-view').addEventListener('click', () => {
          window.location.href = `http://localhost:9847/project/${subdomain}`;
        });

        //document.getElementById('accid-cancel').addEventListener('click', () => history.back());

        // Trip Settings Popup Handlers - DISABLED FOR TUTORIAL MODE
        // document.getElementById('edit-trip-settings').onclick = async function() {
        //   // Load current data and populate popup
        //   const data = await loadData();
        //   const trip = data.trip || {};
        //   const overallPoint = trip["overall-point"] || "";

        //   document.getElementById('countrySelectPopup').value = overallPoint;
        //   document.getElementById('countryStatus').textContent = overallPoint
        //     ? `Saved Main Location: ${getCountryDisplayName(overallPoint)}`
        //     : 'Please Select A Main Location:';

        //   // Show modal
        //   document.getElementById('trip-settings-overlay').style.display = 'flex';
        // };

        // document.getElementById('trip-settings-close').onclick = function() {
        //   document.getElementById('trip-settings-overlay').style.display = 'none';
        // };

        // document.getElementById('trip-settings-save').onclick = async function() {
        //   const overallPoint = document.getElementById('countrySelectPopup').value;
        //   const dev_project = (location.hostname.split('.')[0] || '').toLowerCase();

        //   if (!overallPoint) {
        //     alert('Please select a main location');
        //     return;
        //   }

        //   try {
        //     // Map country to map URL
        //     // Save the country selection - maps are now rendered dynamically
        //     const response = await fetch(`/api/gallery/${dev_project}/trip/update`, {
        //       method: 'PUT',
        //       headers: { 'Content-Type': 'application/json' },
        //       body: JSON.stringify({
        //         trip: {
        //           "overall-point": overallPoint
        //         }
        //       })
        //     });

        //     const result = await response.json();

        //     if (result.success) {
        //       currentCountry = overallPoint;
        //       document.getElementById('countryStatus').textContent = `Saved Main Location: ${getCountryDisplayName(overallPoint)}`;
        //       document.getElementById('trip-settings-overlay').style.display = 'none';
        //       alert(`‚úÖ Main location saved: ${getCountryDisplayName(overallPoint)}`);
        //     } else {
        //       alert('‚ùå Failed to save: ' + (result.error || 'Unknown error'));
        //     }
        //   } catch (error) {
        //     console.error('Error saving overall point:', error);
        //     alert('‚ùå Error saving main location: ' + error.message);
        //   }
        // };

      }

      // Universal Grid System Functions
      let currentLocations = [];
      let currentMapImage = '';
      let currentCountry = '';
      let editingCard = null;
      let editingWaypointIndex = null;

      async function openLocationEditor(button) {
        // NEW: Use inline waypoint editor instead of modal overlay
        editingCard = button.closest('.card');

        if (!editingCard) {
          alert('‚ùå Could not find photo card');
          return;
        }

        // Get the photo from the card
        const cardImg = editingCard.querySelector('img');
        const photoUrl = cardImg ? cardImg.src : '';
        const photoFilename = editingCard.dataset.filename || 'photo.jpg';

        console.log('üì∏ Opening inline waypoint editor for:', photoFilename);

        // Load waypoints for THIS specific photo
        await loadPhotoSpecificLocations(photoFilename);

        // Show the inline editor
        const inlineEditor = document.getElementById('waypointEditorInline');
        const photoImg = document.getElementById('waypointPhotoImg');
        const photoLarge = document.getElementById('waypointPhotoLarge');

        // Set the photo
        photoImg.src = photoUrl;
        inlineEditor.classList.add('active');

        // Scroll to the editor
        inlineEditor.scrollIntoView({ behavior: 'smooth', block: 'center' });

        // Render existing waypoints as dots on the photo
        renderWaypointDotsInline();

        // Populate the "Link to" dropdown with all photos
        await populateInlineLinkDropdown();

        // Set up click handler on photo to add waypoints
        photoLarge.onclick = function (e) {
          if (e.target === photoImg || e.target === photoLarge) {
            const rect = photoImg.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            const xPercent = (x / rect.width) * 100;
            const yPercent = (y / rect.height) * 100;

            addWaypointAtPosition(xPercent, yPercent);
          }
        };
      }

      function closeLocationEditor() {
        document.getElementById('gridOverlay').style.display = 'none';
        // Refresh all location dropdowns to ensure they show current locations
        updateAllLocationDropdowns();
        //editingCard = null;
      }

      // NEW: Inline Waypoint Editor Functions
      function closeInlineWaypointEditor() {
        const inlineEditor = document.getElementById('waypointEditorInline');
        inlineEditor.classList.remove('active');
        document.getElementById('waypointFormInline').style.display = 'none';
        editingWaypointIndex = null;
      }

      function renderWaypointDotsInline() {
        const photoLarge = document.getElementById('waypointPhotoLarge');
        const listContainer = document.getElementById('waypointListInline');

        // Clear existing dots
        photoLarge.querySelectorAll('.waypoint-dot').forEach(dot => dot.remove());

        // Render dots for each waypoint
        currentLocations.forEach((waypoint, index) => {
          const dot = document.createElement('div');
          dot.className = 'waypoint-dot';
          dot.style.left = `${waypoint.xPercent}%`;
          dot.style.top = `${waypoint.yPercent}%`;
          dot.textContent = waypoint.emoji || 'üìç';
          dot.onclick = (e) => {
            e.stopPropagation();
            editWaypointInline(index);
          };
          photoLarge.appendChild(dot);
        });

        // Update waypoint list
        if (currentLocations.length === 0) {
          listContainer.innerHTML = '<p style="color: #999; font-size: 13px; margin: 0;">No waypoints yet. Click on the photo to add one!</p>';
        } else {
          listContainer.innerHTML = currentLocations.map((wp, index) => `
          <div class="waypoint-list-item ${editingWaypointIndex === index ? 'active' : ''}" onclick="editWaypointInline(${index})">
            <span>${wp.emoji || 'üìç'} ${wp.title || wp.name || 'Untitled'}</span>
            <span style="font-size: 12px; opacity: 0.7;">${wp.type || 'rest-stop'}</span>
          </div>
        `).join('');
        }
      }

      function addWaypointAtPosition(xPercent, yPercent) {
        const title = prompt('Enter waypoint title:');
        if (!title || !title.trim()) return;

        const newWaypoint = {
          name: title.trim(),
          title: title.trim(),
          xPercent: xPercent,
          yPercent: yPercent,
          emoji: 'üìç',
          type: 'rest-stop',
          description: '',
          linkedPhotoId: '',
          infoTerms: []
        };

        currentLocations.push(newWaypoint);
        renderWaypointDotsInline();

        // Auto-select the new waypoint for editing
        editWaypointInline(currentLocations.length - 1);
      }

      function editWaypointInline(index) {
        editingWaypointIndex = index;
        const waypoint = currentLocations[index];

        // Show the form
        document.getElementById('waypointFormInline').style.display = 'block';

        // Populate form fields
        document.getElementById('waypointTypeInline').value = waypoint.type || 'rest-stop';
        document.getElementById('waypointTitleInline').value = waypoint.title || waypoint.name || '';
        document.getElementById('waypointEmojiInline').value = waypoint.emoji || 'üìç';
        document.getElementById('waypointDescInline').value = waypoint.description || '';
        document.getElementById('waypointLinkInline').value = waypoint.linkedPhotoId || '';
        document.getElementById('waypointTermsInline').value = (waypoint.infoTerms || []).join(', ');

        // Show connected waypoints based on matching info terms
        showConnectedWaypointsInline(waypoint);

        // Update list to highlight selected
        renderWaypointDotsInline();
      }

      function showConnectedWaypointsInline(waypoint) {
        const previewDiv = document.getElementById('connectedWaypointsPreviewInline');
        const listDiv = document.getElementById('connectedWaypointsListInline');

        if (!waypoint.infoTerms || waypoint.infoTerms.length === 0) {
          previewDiv.style.display = 'none';
          return;
        }

        // Find other waypoints with matching info terms
        const connectedWaypoints = currentLocations.filter((wp, idx) => {
          if (idx === editingWaypointIndex) return false;
          if (!wp.infoTerms) return false;
          return wp.infoTerms.some(term => waypoint.infoTerms.includes(term));
        });

        if (connectedWaypoints.length === 0) {
          previewDiv.style.display = 'none';
          return;
        }

        previewDiv.style.display = 'block';
        listDiv.innerHTML = connectedWaypoints.map(wp =>
          `<div style="margin-bottom: 6px; padding: 6px; background: white; border-radius: 4px;">
          ${wp.emoji || 'üìç'} <strong>${wp.title || wp.name}</strong>
          <div style="font-size: 11px; color: #999; margin-top: 2px;">Type: ${wp.type || 'rest-stop'}</div>
        </div>`
        ).join('');
      }

      function saveCurrentWaypoint() {
        if (editingWaypointIndex === null) return;

        const waypoint = currentLocations[editingWaypointIndex];
        waypoint.type = document.getElementById('waypointTypeInline').value;
        waypoint.title = document.getElementById('waypointTitleInline').value.trim();
        waypoint.name = waypoint.title; // Keep name in sync
        waypoint.emoji = document.getElementById('waypointEmojiInline').value.trim();
        waypoint.description = document.getElementById('waypointDescInline').value.trim();
        waypoint.linkedPhotoId = document.getElementById('waypointLinkInline').value.trim();

        const termsInput = document.getElementById('waypointTermsInline').value;
        waypoint.infoTerms = termsInput ? termsInput.split(',').map(t => t.trim()).filter(t => t) : [];

        console.log('‚úÖ Waypoint saved:', waypoint);

        // Update connected waypoints preview
        showConnectedWaypointsInline(waypoint);

        // Update display
        renderWaypointDotsInline();

        // Update the waypoint summary in the card
        updateWaypointSummaryInCard();

        alert('‚úÖ Waypoint saved!\n\nDon\'t forget to click "Save All Edits" at the top to save your changes.');
      }

      function updateWaypointSummaryInCard() {
        // Update the waypoint summary section in the editing card
        if (!editingCard) return;

        const summaryDiv = editingCard.querySelector('.waypoint-summary');
        if (!summaryDiv) return;

        const countDiv = summaryDiv.querySelector('.waypoint-count');
        const listDiv = summaryDiv.querySelector('.waypoint-list-mini');

        if (countDiv) {
          countDiv.textContent = `${currentLocations.length} waypoint(s)`;
        }

        if (listDiv) {
          if (currentLocations.length === 0) {
            listDiv.innerHTML = '<div style="color: #999; font-style: italic;">No waypoints yet. Click "Edit Photo Locations" to add.</div>';
          } else {
            listDiv.innerHTML = currentLocations.map(wp => `
            <div style="background: white; padding: 6px 10px; margin-bottom: 6px; border-radius: 4px; border: 1px solid #dee2e6;">
              <div style="font-weight: 600;">${wp.emoji || 'üìç'} ${wp.title || wp.name || 'Untitled'}</div>
              <div style="font-size: 11px; color: #999;">Type: ${wp.type || 'rest-stop'}</div>
              ${wp.infoTerms && wp.infoTerms.length > 0 ? `<div style="font-size: 11px; color: #667eea;">Tags: ${wp.infoTerms.join(', ')}</div>` : ''}
            </div>
          `).join('');
          }
        }
      }

      function deleteCurrentWaypoint() {
        if (editingWaypointIndex === null) return;

        const waypoint = currentLocations[editingWaypointIndex];
        if (confirm(`Delete waypoint "${waypoint.title || waypoint.name}"?`)) {
          currentLocations.splice(editingWaypointIndex, 1);
          document.getElementById('waypointFormInline').style.display = 'none';
          editingWaypointIndex = null;
          renderWaypointDotsInline();
          updateWaypointSummaryInCard(); // Update card summary
        }
      }

      async function populateInlineLinkDropdown() {
        const dropdown = document.getElementById('waypointLinkInline');
        if (!dropdown) return;

        try {
          const response = await fetch('../gallery-data.json');
          const galleryData = await response.json();
          const photos = galleryData.photos || [];

          dropdown.innerHTML = '<option value="">None - No link</option>';

          photos.forEach(photo => {
            const option = document.createElement('option');
            option.value = photo.filename;
            option.textContent = `${photo.title || photo.filename}`;
            dropdown.appendChild(option);
          });

          console.log(`üì∏ Loaded ${photos.length} photos into link dropdown`);
        } catch (error) {
          console.error('Error loading photos for dropdown:', error);
          dropdown.innerHTML = '<option value="">Error loading photos</option>';
        }
      }

      function uploadPhotoForCard() {
        // Use the existing ImgBB uploader to upload a new photo for the current card
        if (window.accidImageUploader && editingCard) {
          window.accidImageUploader.show({
            allowDropbox: false,
            onSelect: (imageUrl) => {
              console.log('üì§ New photo uploaded:', imageUrl);

              // Update the photo in the location editor overlay background
              const photoBackground = document.querySelector('#mapBackground img');
              if (photoBackground) {
                photoBackground.src = imageUrl;
              }

              // Update the photo in the card
              const cardImg = editingCard.querySelector('img');
              if (cardImg) {
                cardImg.src = imageUrl;
              }

              // Update the data structure
              const filename = editingCard.dataset.filename;
              const data = window.GALLERY_DATA || { photos: [] };
              const photoData = data.photos.find(p => p.filename === filename);
              if (photoData) {
                photoData.cloudUrl = imageUrl;
                console.log('‚úÖ Updated photo data for:', filename);
              }

              alert('‚úÖ Photo updated! The new photo is now shown in the location editor.\n\nDon\'t forget to click "Save All Edits" to save your changes.');
            }
          });
        } else {
          alert('‚ùå Image uploader not available or no card selected');
        }
      }

      function replacePhotoForCard(button) {
        // Set the editing card to the parent card
        editingCard = button.closest('.card');

        if (!editingCard) {
          alert('‚ùå Could not find photo card');
          return;
        }

        // Get project name from hostname
        const dev_project = (location.hostname.split('.')[0] || '').toLowerCase();

        // Use ACCIDImagePicker (universal image picker)
        if (window.ACCIDImagePicker) {
          window.ACCIDImagePicker.open({
            project: dev_project,
            onSelect: (imageUrl, filename) => {
              console.log('üîÑ Photo replaced:', imageUrl, filename);

              // Update the photo in the card
              const cardImg = editingCard.querySelector('img');
              if (cardImg) {
                cardImg.src = imageUrl;
              }

              // Update the data structure
              const cardFilename = editingCard.dataset.filename;
              const data = window.GALLERY_DATA || { photos: [] };
              const photoData = data.photos.find(p => p.filename === cardFilename);
              if (photoData) {
                photoData.cloudUrl = imageUrl;
                console.log('‚úÖ Replaced photo for:', cardFilename);
              }

              alert('‚úÖ Photo replaced successfully!\n\nDon\'t forget to click "Save All Edits" to save your changes.');
            }
          });
        } else {
          alert('‚ùå ACCIDImagePicker not available. Make sure accid-image-picker.js is loaded.');
        }
      }

      async function loadPhotoSpecificLocations(photoFilename) {
        // Load waypoints for THIS specific photo only
        try {
          const dev_project = (location.hostname.split('.')[0] || '').toLowerCase();

          // Try to load from API first
          const resp = await fetch(`/api/gallery/${dev_project}/waypoints/${photoFilename}`);
          const result = await resp.json();

          if (result.success) {
            currentLocations = result.waypoints || [];
            console.log(`üì∏ Loaded ${currentLocations.length} waypoints for photo:`, photoFilename);
          } else {
            // Fallback to loading from gallery-data.json
            const data = await loadData();
            const photoData = data.photos.find(p => p.filename === photoFilename);
            currentLocations = (photoData && photoData["sub-points"]) || [];
            console.log(`üì∏ Loaded ${currentLocations.length} waypoints (from JSON) for photo:`, photoFilename);
          }

          updateLocationList();
          generateUniversalGrid();
        } catch (e) {
          console.error('Error loading photo waypoints:', e);
          currentLocations = [];
          updateLocationList();
          generateUniversalGrid();
        }
      }

      async function loadExistingLocations() {
        try {
          const data = await loadData();
          currentLocations = (data.trip && data.trip["sub-points"]) || [];
          console.log('üó∫Ô∏è loadExistingLocations loaded:', currentLocations);
          updateLocationList();
          updateAllLocationDropdowns();
        } catch (e) {
          console.error('Failed to load locations:', e);
          currentLocations = [];
        }
      }

      function generateUniversalGrid() {
        const grid = document.getElementById('universalGrid');
        if (!grid) {
          console.error('universalGrid element not found');
          return;
        }
        const mapContainer = grid.parentElement;
        grid.innerHTML = '';

        // Remove grid cells - now just a click overlay
        grid.style.display = 'block';
        grid.style.cursor = 'crosshair';

        // Add click handler to capture percentage position
        grid.onclick = (e) => {
          const rect = mapContainer.getBoundingClientRect();
          const x = e.clientX - rect.left;
          const y = e.clientY - rect.top;
          const xPercent = (x / rect.width) * 100;
          const yPercent = (y / rect.height) * 100;

          addLocationAtPosition(xPercent, yPercent);
        };

        // Render existing location dots
        renderLocationDots();
      }

      function renderLocationDots() {
        const grid = document.getElementById('universalGrid');

        // Clear existing dots
        grid.querySelectorAll('.location-dot').forEach(dot => dot.remove());

        // Render dots for each location
        currentLocations.forEach((loc, index) => {
          const dot = document.createElement('div');
          dot.className = 'location-dot';
          dot.style.position = 'absolute';
          dot.style.left = `${loc.xPercent}%`;
          dot.style.top = `${loc.yPercent}%`;
          dot.style.transform = 'translate(-50%, -50%)';
          dot.style.width = '20px';
          dot.style.height = '20px';
          dot.style.borderRadius = '50%';
          dot.style.background = 'rgba(40, 167, 69, 0.8)';
          dot.style.border = '2px solid white';
          dot.style.cursor = 'pointer';
          dot.style.zIndex = '10';
          dot.title = loc.name;

          // Click to remove
          dot.onclick = (e) => {
            e.stopPropagation();
            if (confirm(`Remove location "${loc.name}"?`)) {
              currentLocations.splice(index, 1);
              renderLocationDots();
              updateLocationList();
            }
          };

          grid.appendChild(dot);
        });
      }

      function addLocationAtPosition(xPercent, yPercent) {
        const locationName = prompt(`Enter name for this waypoint:`);
        if (!locationName || !locationName.trim()) return;

        // Create new waypoint with enhanced properties
        const newWaypoint = {
          name: locationName.trim(),
          title: locationName.trim(), // Also use as title
          xPercent: xPercent,
          yPercent: yPercent,
          gridPosition: `${xPercent.toFixed(1)}%, ${yPercent.toFixed(1)}%`,
          emoji: 'üìç', // Default emoji
          opacity: 1.0, // Default full opacity
          linkedPhotoId: '', // Can link to another photo
          description: '', // Waypoint description
          notes: '', // Additional notes
          infoTerms: [] // Terms for semantic linking
        };

        currentLocations.push(newWaypoint);

        renderLocationDots();
        updateLocationList();

        // Prompt to edit additional properties
        const editMore = confirm(`Waypoint "${locationName}" added!\n\nWould you like to add more details (link to photo, emoji, etc.)?`);
        if (editMore) {
          editWaypointDetails(currentLocations.length - 1);
        }
      }

      function editWaypointDetails(waypointIndex) {
        const waypoint = currentLocations[waypointIndex];
        if (!waypoint) return;

        // Simple form for editing waypoint details
        const emoji = prompt(`Enter emoji for "${waypoint.name}" (or leave blank):`, waypoint.emoji || 'üìç');
        if (emoji !== null) waypoint.emoji = emoji;

        const linkedPhoto = prompt(`Link to another photo? Enter photo filename (or leave blank):`, waypoint.linkedPhotoId || '');
        if (linkedPhoto !== null) waypoint.linkedPhotoId = linkedPhoto;

        const opacity = prompt(`Opacity (0.0 to 1.0):`, waypoint.opacity || '1.0');
        if (opacity !== null) waypoint.opacity = parseFloat(opacity) || 1.0;

        const description = prompt(`Description:`, waypoint.description || '');
        if (description !== null) waypoint.description = description;

        renderLocationDots();
        updateLocationList();

        console.log('‚úÖ Waypoint updated:', waypoint);
      }



      function updateLocationList() {
        const list = document.getElementById('locationList');
        if (currentLocations.length === 0) {
          list.innerHTML = '<p class="no-locations-message">No locations set. Click on the map grid to add locations.</p>';
          return;
        }

        const getTypeEmoji = (type) => {
          switch (type) {
            case 'grouper': return 'üìÅ';
            case 'info': return 'üìÑ';
            case 'rest-stop': return 'üõë';
            default: return 'üìç';
          }
        };

        list.innerHTML = currentLocations.map((loc, index) => {
          const emoji = loc.emoji || getTypeEmoji(loc.type);
          const linkedInfo = loc.linkedPhotoId ? `<br><small style="color: #667eea;">üîó ${loc.linkedPhotoId}</small>` : '';
          const opacityInfo = loc.opacity !== undefined && loc.opacity !== 1.0 ? ` <small style="color: #999;">(${Math.round(loc.opacity * 100)}%)</small>` : '';

          return `
          <div class="location-item">
            <span>
              <strong>${emoji} ${loc.title || loc.name}</strong>${opacityInfo}
              ${linkedInfo}
            </span>
            <div style="display: flex; gap: 5px;">
              <button class="edit-waypoint" onclick="editWaypoint(${index})" title="Edit waypoint info">‚úèÔ∏è</button>
              <button class="delete-location" onclick="deleteLocation(${index})">üóëÔ∏è</button>
            </div>
          </div>
        `;
        }).join('');
      }

      function deleteLocation(index) {
        const location = currentLocations[index];
        currentLocations.splice(index, 1);

        // Remove visual indicator from grid
        const cell = document.querySelector(`[data-row="${location.row}"][data-col="${location.col}"]`);
        if (cell) {
          cell.classList.remove('occupied');
          const dot = cell.querySelector('.location-dot');
          if (dot) dot.remove();
        }

        updateLocationList();
      }

      async function editWaypoint(index) {
        editingWaypointIndex = index;
        const waypoint = currentLocations[index];

        // Populate modal with waypoint data
        document.getElementById('waypoint-type').value = waypoint.type || 'rest-stop';
        document.getElementById('waypoint-title').value = waypoint.title || waypoint.name || '';
        document.getElementById('waypoint-description').value = waypoint.description || '';
        document.getElementById('waypoint-info-terms').value = (waypoint.infoTerms || []).join(', ');

        // Populate perspective dropdown
        populatePerspectiveDropdown(waypoint.perspective || '');

        // Populate photo dropdown from gallery-data.json
        await populatePhotoDropdown(waypoint.linkedPhotoId || '');

        // Populate emoji, opacity fields
        if (document.getElementById('waypoint-emoji')) {
          document.getElementById('waypoint-emoji').value = waypoint.emoji || 'üìç';
        }
        if (document.getElementById('waypoint-opacity')) {
          document.getElementById('waypoint-opacity').value = waypoint.opacity !== undefined ? waypoint.opacity : 1.0;
        }

        // Show connections preview
        updateWaypointConnectionsPreview(waypoint);

        // Show modal
        document.getElementById('waypointModal').style.display = 'flex';
      }

      function populatePerspectiveDropdown(selectedPerspective = '') {
        const dropdown = document.getElementById('waypoint-perspective');
        if (!dropdown) return;

        // Clear existing options
        dropdown.innerHTML = '<option value="">üëÅÔ∏è No Perspective</option>';

        // Add option for each perspective
        perspectives.forEach(p => {
          const option = document.createElement('option');
          option.value = p.name;
          option.textContent = `${p.name}`;
          option.style.color = p.color;

          // Select if this is the current perspective
          if (p.name === selectedPerspective) {
            option.selected = true;
          }

          dropdown.appendChild(option);
        });

        console.log(`üëÅÔ∏è Loaded ${perspectives.length} perspectives into dropdown, selected: ${selectedPerspective}`);
      }

      async function populatePhotoDropdown(selectedFilename = '') {
        const dropdown = document.getElementById('waypoint-linked-photo');
        if (!dropdown) return;

        try {
          // Load gallery-data.json to get all photos
          const response = await fetch('../gallery-data.json');
          const galleryData = await response.json();
          const photos = galleryData.photos || [];

          // Clear existing options except the first one (None)
          dropdown.innerHTML = '<option value="">None - No link</option>';

          // Add option for each photo
          photos.forEach(photo => {
            const option = document.createElement('option');
            option.value = photo.filename;
            option.textContent = `${photo.title || photo.filename} (${photo.location || 'Unknown'})`;

            // Select if this is the currently linked photo
            if (photo.filename === selectedFilename) {
              option.selected = true;
            }

            dropdown.appendChild(option);
          });

          console.log(`üì∏ Loaded ${photos.length} photos into link dropdown`);
        } catch (error) {
          console.error('Error loading photos for dropdown:', error);
          dropdown.innerHTML = '<option value="">Error loading photos</option>';
        }
      }

      function updateWaypointConnectionsPreview(waypoint) {
        const previewDiv = document.getElementById('waypoint-connections-preview');
        const listDiv = document.getElementById('waypoint-connections-list');

        if (!waypoint.infoTerms || waypoint.infoTerms.length === 0) {
          previewDiv.style.display = 'none';
          return;
        }

        // Find other waypoints with matching info terms
        const connectedWaypoints = currentLocations.filter((wp, idx) => {
          if (idx === editingWaypointIndex) return false;
          if (!wp.infoTerms) return false;
          return wp.infoTerms.some(term => waypoint.infoTerms.includes(term));
        });

        if (connectedWaypoints.length === 0) {
          previewDiv.style.display = 'none';
          return;
        }

        previewDiv.style.display = 'block';
        listDiv.innerHTML = connectedWaypoints.map(wp =>
          `<div style="margin-top:4px;">‚Ä¢ ${wp.title || wp.name} (${wp.type || 'rest-stop'})</div>`
        ).join('');
      }

      function closeWaypointModal() {
        document.getElementById('waypointModal').style.display = 'none';
        editingWaypointIndex = null;
      }

      function saveWaypoint() {
        if (editingWaypointIndex === null) return;

        const waypoint = currentLocations[editingWaypointIndex];
        waypoint.type = document.getElementById('waypoint-type').value;
        waypoint.title = document.getElementById('waypoint-title').value.trim();
        waypoint.description = document.getElementById('waypoint-description').value.trim();
        const termsStr = document.getElementById('waypoint-info-terms').value.trim();
        waypoint.infoTerms = termsStr ? termsStr.split(',').map(t => t.trim()).filter(Boolean) : [];

        // Save perspective
        if (document.getElementById('waypoint-perspective')) {
          const selectedPerspective = document.getElementById('waypoint-perspective').value;
          if (selectedPerspective) {
            const perspective = perspectives.find(p => p.name === selectedPerspective);
            if (perspective) {
              waypoint.perspective = perspective.name;
              waypoint.perspectiveDesc = perspective.desc;
              console.log(`üíæ Saved perspective to waypoint: ${perspective.name}`);
            }
          } else {
            // Clear perspective if "No Perspective" selected
            delete waypoint.perspective;
            delete waypoint.perspectiveDesc;
            console.log(`üíæ Cleared perspective from waypoint`);
          }
        }

        // NEW: Save linkedPhotoId, emoji, opacity
        if (document.getElementById('waypoint-linked-photo')) {
          waypoint.linkedPhotoId = document.getElementById('waypoint-linked-photo').value.trim();
        }
        if (document.getElementById('waypoint-emoji')) {
          waypoint.emoji = document.getElementById('waypoint-emoji').value.trim() || 'üìç';
        }
        if (document.getElementById('waypoint-opacity')) {
          waypoint.opacity = parseFloat(document.getElementById('waypoint-opacity').value) || 1.0;
        }

        updateLocationList();
        closeWaypointModal();
      }

      async function clearAllLocations() {
        if (!confirm('Clear all locations? This will also clear location assignments from all photos. This cannot be undone.')) {
          return;
        }

        try {
          // Clear the locations array
          currentLocations = [];
          generateUniversalGrid();
          updateLocationList();

          // Clear sub-point fields from ALL photos
          const data = await loadData();
          const dev_project = (location.hostname.split('.')[0] || '').toLowerCase();

          if (data.photos && Array.isArray(data.photos)) {
            // Build update payload to clear all sub-point fields from all photos
            const updates = [];
            data.photos.forEach(photo => {
              updates.push({
                filename: photo.filename,
                fields: {
                  "sub-point-name": "",
                  "sub-point-position": "",
                  "sub-point-x": "",
                  "sub-point-y": ""
                }
              });
            });

            // Send batch update to clear all photo sub-point assignments
            const response = await fetch(`/api/gallery/${dev_project}/photos/update`, {
              method: 'PUT',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ updates })
            });

            const result = await response.json();

            if (result.success) {
              console.log('‚úÖ Cleared sub-point assignments from all photos');
              alert('‚úÖ All locations cleared from map and photos!');
            } else {
              console.error('Failed to clear photo assignments:', result.error);
              alert('‚ö†Ô∏è Locations cleared from map, but failed to update photos: ' + result.error);
            }
          }

        } catch (error) {
          console.error('Error clearing locations:', error);
          alert('‚ùå Error clearing locations: ' + error.message);
        }
      }

      async function saveLocations() {
        const dev_project = (location.hostname.split('.')[0] || '').toLowerCase();

        try {
          // Save waypoints to THIS specific photo (not global trip data)
          if (!editingCard) {
            alert('‚ùå No photo selected');
            return;
          }

          const photoFilename = editingCard.dataset.filename;
          console.log(`üíæ Saving ${currentLocations.length} waypoints to photo:`, photoFilename);

          const payload = {
            filename: photoFilename,
            waypoints: currentLocations
          };

          const resp = await fetch(`/api/gallery/${dev_project}/waypoints/save`, {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
          });

          const result = await resp.json();
          console.log('‚úÖ Save result:', result);
          if (!result.success) throw new Error(result.error || 'Failed to save waypoints');

          // Update the location dropdown for this specific card
          updateLocationDropdownForCard(editingCard);

          closeLocationEditor();

          alert(`‚úÖ Saved ${currentLocations.length} waypoints to photo: ${photoFilename}`);

        } catch (e) {
          console.error('Failed to save waypoints:', e);
          alert('‚ùå Failed to save waypoints: ' + e.message);
        }
      }

      function updateLocationDropdownForCard(card) {
        // Update the location dropdown for a specific card with its photo's sub-points
        const select = card.querySelector('.ef-sub-point-name');
        if (!select) return;

        const filename = card.dataset.filename;
        const savedValue = select.value; // Keep current selection

        console.log(`üìù Updating dropdown for card: ${filename} with ${currentLocations.length} locations`);

        // Clear and rebuild options
        select.innerHTML = '<option value="">Select Sub-Location...</option>';

        currentLocations.forEach(loc => {
          const option = document.createElement('option');
          option.value = loc.name;
          option.textContent = loc.name;
          if (loc.name === savedValue) {
            option.selected = true;
          }
          select.appendChild(option);
        });
      }

      function updateAllLocationDropdowns() {
        console.log('üîÑ Updating all location dropdowns with currentLocations:', currentLocations);

        // Update all sub-point dropdowns in edit fields
        document.querySelectorAll('.card').forEach(card => {
          const select = card.querySelector('.ef-sub-point-name');
          if (!select) return;

          // Get the photo's saved sub-point value from the card's data
          const filename = card.dataset.filename;
          const savedValue = select.value; // Keep current selection

          console.log('üìù Updating dropdown for card:', filename, 'saved value:', savedValue);

          // Clear and rebuild options
          select.innerHTML = '<option value="">Select Sub-Location...</option>';

          currentLocations.forEach(loc => {
            const option = document.createElement('option');
            option.value = loc.name;
            option.textContent = loc.name;
            select.appendChild(option);
          });

          // Restore previous value if it still exists
          if (savedValue && currentLocations.some(loc => loc.name === savedValue)) {
            select.value = savedValue;
            console.log('‚úÖ Restored value:', savedValue, 'for card:', filename);
          }
        });
      }

      // Function to standardize row heights based on tallest photo in each row
      function standardizeRowHeights() {
        const grid = document.getElementById('grid');
        if (!grid) return;

        const cards = Array.from(grid.querySelectorAll('.card'));
        if (cards.length === 0) return;

        // Wait for images to load before calculating heights
        const images = cards.map(card => card.querySelector('img')).filter(img => img);
        let loadedCount = 0;

        function checkAllLoaded() {
          loadedCount++;
          if (loadedCount === images.length) {
            calculateRowHeights();
          }
        }

        // Listen for image load events
        images.forEach(img => {
          if (img.complete) {
            checkAllLoaded();
          } else {
            img.addEventListener('load', checkAllLoaded);
            img.addEventListener('error', checkAllLoaded); // Handle broken images
          }
        });

        function calculateRowHeights() {
          // Get computed grid styles to determine columns per row
          const gridStyle = getComputedStyle(grid);
          const columns = gridStyle.gridTemplateColumns.split(' ').length;

          // Group cards into rows
          const rows = [];
          for (let i = 0; i < cards.length; i += columns) {
            rows.push(cards.slice(i, i + columns));
          }

          // For each row, find the tallest image and set all images to that height
          rows.forEach(rowCards => {
            let maxHeight = 0;

            // First pass: find the tallest natural image height in this row
            rowCards.forEach(card => {
              const img = card.querySelector('img');
              if (img && img.complete) {
                const naturalHeight = (img.naturalHeight / img.naturalWidth) * img.offsetWidth;
                maxHeight = Math.max(maxHeight, naturalHeight);
              }
            });

            // Second pass: set all images in this row to the max height
            if (maxHeight > 0) {
              rowCards.forEach(card => {
                const img = card.querySelector('img');
                if (img) {
                  img.style.height = `${maxHeight}px`;
                  img.style.objectFit = 'contain';
                  img.style.objectPosition = 'center';
                }
              });
            }
          });
        }
      }

      // Emoji picker functions
      function togglePhotoFields(button) {
        const card = button.closest('.card');
        const editFields = card.querySelector('.edit-fields');
        const icon = button.querySelector('.toggle-icon');

        if (editFields.style.display === 'none') {
          editFields.style.display = 'block';
          icon.textContent = '‚ñ≤';
          button.innerHTML = '<span class="toggle-icon">‚ñ≤</span> Hide Details';
          button.style.background = '#e7f3ff';
          button.style.borderColor = '#667eea';
          button.style.color = '#667eea';
        } else {
          editFields.style.display = 'none';
          icon.textContent = '‚ñº';
          button.innerHTML = '<span class="toggle-icon">‚ñº</span> Show Details';
          button.style.background = '#f8f9fa';
          button.style.borderColor = '#dee2e6';
          button.style.color = '#495057';
        }
      }

      function toggleEmojiPicker(button) {
        const categories = button.nextElementSibling;
        const isVisible = categories.classList.contains('show');

        // Close all other emoji pickers
        document.querySelectorAll('.emoji-categories.show').forEach(el => {
          el.classList.remove('show');
        });

        // Toggle this one
        if (!isVisible) {
          categories.classList.add('show');
          button.textContent = 'Close';
        } else {
          categories.classList.remove('show');
          button.textContent = 'Choose Emoji';
        }
      }

      function selectEmoji(button, emoji) {
        // Find the emoji input field in the same card
        const card = button.closest('.card');
        const emojiInput = card.querySelector('.ef-emoji');

        if (emojiInput) {
          emojiInput.value = emoji;
          // Close the picker
          const categories = button.closest('.emoji-categories');
          const toggleBtn = categories.previousElementSibling;
          categories.classList.remove('show');
          toggleBtn.textContent = 'Choose Emoji';
        }
      }

      // Close emoji pickers when clicking outside
      document.addEventListener('click', (e) => {
        if (!e.target.closest('.emoji-picker')) {
          document.querySelectorAll('.emoji-categories.show').forEach(el => {
            el.classList.remove('show');
            const toggleBtn = el.previousElementSibling;
            if (toggleBtn) toggleBtn.textContent = 'Choose Emoji';
          });
        }
      });

      // Initialize location dropdowns when page loads
      document.addEventListener('DOMContentLoaded', () => {
        setTimeout(loadExistingLocations, 100); // Small delay to ensure DOM is ready

        // Setup waypoint modal event listeners
        document.getElementById('waypoint-close').onclick = closeWaypointModal;
        document.getElementById('waypoint-cancel').onclick = closeWaypointModal;
        document.getElementById('waypoint-save').onclick = saveWaypoint;

        // Close modal when clicking outside
        document.getElementById('waypointModal').onclick = (e) => {
          if (e.target.id === 'waypointModal') closeWaypointModal();
        };
      });

      // Populate country dropdowns with all available countries
      function populateCountryDropdowns() {
        const dropdowns = document.querySelectorAll('#countrySelectPopup, #countrySelect');

        dropdowns.forEach(dropdown => {
          if (!dropdown) return;

          // Clear existing options except the first one
          const firstOption = dropdown.querySelector('option[value=""]');
          dropdown.innerHTML = '';
          if (firstOption) {
            dropdown.appendChild(firstOption);
          } else {
            dropdown.innerHTML = '<option value="">Choose A Main Location...</option>';
          }

          // Add all countries from countryPaths - sorted alphabetically
          const sortedCountries = Object.entries(countryPaths)
            .sort((a, b) => a[1].name.localeCompare(b[1].name));

          sortedCountries.forEach(([code, country]) => {
            const option = document.createElement('option');
            option.value = code;
            option.textContent = `${country.name}`;
            dropdown.appendChild(option);
          });
        });
      }

      document.addEventListener('DOMContentLoaded', () => {
        // Wait for country-paths.js to load, then populate dropdowns
        if (typeof countryPaths !== 'undefined') {
          populateCountryDropdowns();
        } else {
          // Retry after a short delay if countryPaths isn't loaded yet
          setTimeout(() => {
            if (typeof countryPaths !== 'undefined') {
              populateCountryDropdowns();
            }
          }, 100);
        }

        init();
      });
    </script>

    <script>
      const params = new URLSearchParams(window.location.search);
      if (params.get("edit") === "1") {
        document.body.classList.add("edit-mode");
      }

      // Preview Panel functionality
      document.addEventListener('DOMContentLoaded', () => {
        const previewPanel = document.getElementById('preview-panel');
        const previewIframe = document.getElementById('preview-iframe');
        const previewTitle = document.getElementById('preview-title');
        const closePreviewBtn = document.getElementById('close-preview');
        const previewTabs = document.querySelectorAll('.preview-tab');

        // Handle tab clicks
        previewTabs.forEach(tab => {
          tab.addEventListener('click', () => {
            const template = tab.getAttribute('data-template');
            const templateUrl = `../${template}/`;

            // Update iframe and title
            previewIframe.src = templateUrl;
            previewTitle.textContent = `${tab.textContent} Preview`;

            // Show preview panel
            previewPanel.style.display = 'block';

            // Mark tab as active
            previewTabs.forEach(t => t.classList.remove('active'));
            tab.classList.add('active');
          });
        });

        // Handle close button
        closePreviewBtn.addEventListener('click', () => {
          previewPanel.style.display = 'none';
          previewIframe.src = '';
          previewTabs.forEach(t => t.classList.remove('active'));
        });

        // Close preview with ESC key
        document.addEventListener('keydown', (e) => {
          if (e.key === 'Escape' && previewPanel.style.display === 'block') {
            previewPanel.style.display = 'none';
            previewIframe.src = '';
            previewTabs.forEach(t => t.classList.remove('active'));
          }
        });
      });
    </script>

    <script src="../maps/country-paths.js?v=2"></script>
    <script src="../gallery-editor.js"></script>
  </div><!-- End editor-content -->

  <!-- Navigation tabs with preview panel - click tabs to see gallery layouts while editing -->

  <!-- Admin Modules: Auto-loaded from admin-panels/ folder -->

  <!-- ACCID Health Module -->
  <!--div id="accid-health-mount"></div-->
  <!--
  <script id="accid-health-loader">
  (function(){
      const mount = document.getElementById('accid-health-mount');
      const self = document.getElementById('accid-health-loader');
      const destroy = () => {
          if (mount?.parentNode) mount.parentNode.removeChild(mount);
          if (self?.parentNode) self.parentNode.removeChild(self);
      };
      async function init() {
          if (localStorage.getItem('accid-module-accid-health-disabled') === 'true') { destroy(); return; }
          try {
              const dropper = await fetch('../accid_dropper.json', { cache: 'no-cache' }).then(r => r.json());
              if (!dropper.admin_modules?.['accid-health']?.enabled) { destroy(); return; }
              const response = await fetch('../admin-panels/accid-health.html', { cache: 'no-cache' });
              mount.innerHTML = await response.text();
          } catch (e) {}
      }
      if (document.readyState === 'loading') { document.addEventListener('DOMContentLoaded', init); } else { init(); }
  })();
  </script>
-->
  <!-- ACCID Health Helper Module
  <div id="accid-health-helper-mount"></div>
  <script id="accid-health-helper-loader">
  (function(){
      const mount = document.getElementById('accid-health-helper-mount');
      const self = document.getElementById('accid-health-helper-loader');
      const destroy = () => {
          if (mount?.parentNode) mount.parentNode.removeChild(mount);
          if (self?.parentNode) self.parentNode.removeChild(self);
      };
      async function init() {
          if (localStorage.getItem('accid-module-accid-health-helper-disabled') === 'true') { destroy(); return; }
          try {
              const dropper = await fetch('../accid_dropper.json', { cache: 'no-cache' }).then(r => r.json());
              if (!dropper.admin_modules?.['accid-health-helper']?.enabled) { destroy(); return; }
              const response = await fetch('../admin-panels/accid-health-helper.html', { cache: 'no-cache' });
              mount.innerHTML = await response.text();
          } catch (e) {}
      }
      if (document.readyState === 'loading') { document.addEventListener('DOMContentLoaded', init); } else { init(); }
  })();
  </script>
-->
  <!-- ACCID Next Steps Module
  <div id="accid-next-steps-mount"></div>
  <script id="accid-next-steps-loader">
  (function(){
      const mount = document.getElementById('accid-next-steps-mount');
      const self = document.getElementById('accid-next-steps-loader');
      const destroy = () => {
          if (mount?.parentNode) mount.parentNode.removeChild(mount);
          if (self?.parentNode) self.parentNode.removeChild(self);
      };
      async function init() {
          if (localStorage.getItem('accid-module-accid-next-steps-disabled') === 'true') { destroy(); return; }
          try {
              const dropper = await fetch('../accid_dropper.json', { cache: 'no-cache' }).then(r => r.json());
              if (!dropper.admin_modules?.['accid-next-steps']?.enabled) { destroy(); return; }
              const response = await fetch('../admin-panels/accid-next-steps.html', { cache: 'no-cache' });
              mount.innerHTML = await response.text();
          } catch (e) {}
      }
      if (document.readyState === 'loading') { document.addEventListener('DOMContentLoaded', init); } else { init(); }
  })();
  </script>
-->
  <!-- Attachment Module -->
  <div id="attachment-module-mount"></div>
  <script id="attachment-module-loader">
    (function () {
      const mount = document.getElementById('attachment-module-mount');
      const self = document.getElementById('attachment-module-loader');
      const destroy = () => {
        if (mount?.parentNode) mount.parentNode.removeChild(mount);
        if (self?.parentNode) self.parentNode.removeChild(self);
      };
      async function init() {
        if (localStorage.getItem('accid-module-attachment-module-disabled') === 'true') { destroy(); return; }
        try {
          const dropper = await fetch('../accid_dropper.json', { cache: 'no-cache' }).then(r => r.json());
          if (!dropper.admin_modules?.['attachment-module']?.enabled) { destroy(); return; }
          const response = await fetch('../admin-panels/attachment-module.html', { cache: 'no-cache' });
          mount.innerHTML = await response.text();
        } catch (e) { }
      }
      if (document.readyState === 'loading') { document.addEventListener('DOMContentLoaded', init); } else { init(); }
    })();
  </script>

  <!-- Dropbox Connector Module -->
  <div id="dropbox-connector-mount"></div>
  <script id="dropbox-connector-loader">
    (function () {
      const mount = document.getElementById('dropbox-connector-mount');
      const self = document.getElementById('dropbox-connector-loader');
      const destroy = () => {
        if (mount?.parentNode) mount.parentNode.removeChild(mount);
        if (self?.parentNode) self.parentNode.removeChild(self);
      };
      async function init() {
        if (localStorage.getItem('accid-module-dropbox-connector-disabled') === 'true') { destroy(); return; }
        try {
          const dropper = await fetch('../accid_dropper.json', { cache: 'no-cache' }).then(r => r.json());
          if (!dropper.admin_modules?.['dropbox-connector']?.enabled) { destroy(); return; }
          const response = await fetch('../admin-panels/dropbox-connector.html', { cache: 'no-cache' });
          mount.innerHTML = await response.text();
        } catch (e) { }
      }
      if (document.readyState === 'loading') { document.addEventListener('DOMContentLoaded', init); } else { init(); }
    })();
  </script>

  <!-- Export Dialog Module
  <div id="export-dialog-mount"></div>
  <script id="export-dialog-loader">
  (function(){
      const mount = document.getElementById('export-dialog-mount');
      const self = document.getElementById('export-dialog-loader');
      const destroy = () => {
          if (mount?.parentNode) mount.parentNode.removeChild(mount);
          if (self?.parentNode) self.parentNode.removeChild(self);
      };
      async function init() {
          if (localStorage.getItem('accid-module-export-dialog-disabled') === 'true') { destroy(); return; }
          try {
              const dropper = await fetch('../accid_dropper.json', { cache: 'no-cache' }).then(r => r.json());
              if (!dropper.admin_modules?.['export-dialog']?.enabled) { destroy(); return; }
              const response = await fetch('../admin-panels/export-dialog.html', { cache: 'no-cache' });
              mount.innerHTML = await response.text();
          } catch (e) {}
      }
      if (document.readyState === 'loading') { document.addEventListener('DOMContentLoaded', init); } else { init(); }
  })();
  </script>
-->
  <!-- Folder Size Module
  <div id="folder-size-mount"></div>
  <script id="folder-size-loader">
  (function(){
      const mount = document.getElementById('folder-size-mount');
      const self = document.getElementById('folder-size-loader');
      const destroy = () => {
          if (mount?.parentNode) mount.parentNode.removeChild(mount);
          if (self?.parentNode) self.parentNode.removeChild(self);
      };
      async function init() {
          if (localStorage.getItem('accid-module-folder-size-disabled') === 'true') { destroy(); return; }
          try {
              const dropper = await fetch('../accid_dropper.json', { cache: 'no-cache' }).then(r => r.json());
              if (!dropper.admin_modules?.['folder-size']?.enabled) { destroy(); return; }
              const response = await fetch('../admin-panels/folder-size.html', { cache: 'no-cache' });
              mount.innerHTML = await response.text();
          } catch (e) {}
      }
      if (document.readyState === 'loading') { document.addEventListener('DOMContentLoaded', init); } else { init(); }
  })();
  </script>
-->
  <!-- Hello World Module
  <div id="hello-world-mount"></div>
  <script id="hello-world-loader">
  (function(){
      const mount = document.getElementById('hello-world-mount');
      const self = document.getElementById('hello-world-loader');
      const destroy = () => {
          if (mount?.parentNode) mount.parentNode.removeChild(mount);
          if (self?.parentNode) self.parentNode.removeChild(self);
      };
      async function init() {
          if (localStorage.getItem('accid-module-hello-world-disabled') === 'true') { destroy(); return; }
          try {
              const dropper = await fetch('../accid_dropper.json', { cache: 'no-cache' }).then(r => r.json());
              if (!dropper.admin_modules?.['hello-world']?.enabled) { destroy(); return; }
              const response = await fetch('../admin-panels/hello-world.html', { cache: 'no-cache' });
              const html = await response.text();
              mount.innerHTML = html;
              // Execute scripts in the injected HTML
              mount.querySelectorAll('script').forEach(oldScript => {
                  const newScript = document.createElement('script');
                  Array.from(oldScript.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value));
                  newScript.textContent = oldScript.textContent;
                  oldScript.parentNode.replaceChild(newScript, oldScript);
              });
          } catch (e) {}
      }
      if (document.readyState === 'loading') { document.addEventListener('DOMContentLoaded', init); } else { init(); }
  })();
  </script>
-->
  <!-- Module Manager Module
  <div id="module-manager-mount"></div>
  <script id="module-manager-loader">
  (function(){
      const mount = document.getElementById('module-manager-mount');
      const self = document.getElementById('module-manager-loader');
      const destroy = () => {
          if (mount?.parentNode) mount.parentNode.removeChild(mount);
          if (self?.parentNode) self.parentNode.removeChild(self);
      };
      async function init() {
          if (localStorage.getItem('accid-module-module-manager-disabled') === 'true') { destroy(); return; }
          try {
              const dropper = await fetch('../accid_dropper.json', { cache: 'no-cache' }).then(r => r.json());
              if (!dropper.admin_modules?.['module-manager']?.enabled) { destroy(); return; }
              const response = await fetch('../admin-panels/module-manager.html', { cache: 'no-cache' });
              const html = await response.text();
              mount.innerHTML = html;
              // Execute scripts in the injected HTML
              mount.querySelectorAll('script').forEach(oldScript => {
                  const newScript = document.createElement('script');
                  Array.from(oldScript.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value));
                  newScript.textContent = oldScript.textContent;
                  oldScript.parentNode.replaceChild(newScript, oldScript);
              });
          } catch (e) {}
      }
      if (document.readyState === 'loading') { document.addEventListener('DOMContentLoaded', init); } else { init(); }
  })();
  </script>
-->
  <!-- Drunk Compass Module
  <script id="drunk-compass-loader">
  (function(){
      const self = document.getElementById('drunk-compass-loader');
      const destroy = () => {
          if (self?.parentNode) self.parentNode.removeChild(self);
          const compass = document.getElementById('drunk-compass');
          if (compass?.parentNode) compass.parentNode.removeChild(compass);
      };
      async function init() {
          if (localStorage.getItem('accid-module-drunk-compass-disabled') === 'true') { destroy(); return; }
          try {
              const dropper = await fetch('../accid_dropper.json', { cache: 'no-cache' }).then(r => r.json());
              if (!dropper.admin_modules?.['drunk-compass']?.enabled) { destroy(); return; }
              const script = document.createElement('script');
              script.src = '../admin-panels/drunk-compass.js?_=' + Date.now();
              document.body.appendChild(script);
          } catch (e) {}
      }
      if (document.readyState === 'loading') { document.addEventListener('DOMContentLoaded', init); } else { init(); }
  })();
  </script>
-->
  <!-- SEO Analyzer Module
  <div id="seo-analyzer-mount"></div>
  <script id="seo-analyzer-loader">
  (function(){
      const mount = document.getElementById('seo-analyzer-mount');
      const self = document.getElementById('seo-analyzer-loader');
      const destroy = () => {
          if (mount?.parentNode) mount.parentNode.removeChild(mount);
          if (self?.parentNode) self.parentNode.removeChild(self);
      };
      async function init() {
          if (localStorage.getItem('accid-module-seo-analyzer-disabled') === 'true') { destroy(); return; }
          try {
              const dropper = await fetch('../accid_dropper.json', { cache: 'no-cache' }).then(r => r.json());
              if (!dropper.admin_modules?.['seo-analyzer']?.enabled) { destroy(); return; }
              const response = await fetch('../admin-panels/seo-analyzer.html', { cache: 'no-cache' });
              mount.innerHTML = await response.text();
          } catch (e) {}
      }
      if (document.readyState === 'loading') { document.addEventListener('DOMContentLoaded', init); } else { init(); }
  })();
  </script>
-->

  <!-- Waypoint Universe Bridge -->
  <script src="../shared/waypoint-data-bridge.js"></script>
  <script src="../shared/waypoint-universe-integration.js"></script>

  <script>
    // üåå WAYPOINT UNIVERSE IFRAME - Only activate on live URLs (not localhost)
    (function () {
      const currentUrl = window.location.href;
      const isLocalhost = currentUrl.includes('localhost') || currentUrl.includes('127.0.0.1');

      if (!isLocalhost) {
        console.log('üåå Live URL detected - connecting to Waypoint Universe');

        // Create hidden iframe to waypoint universe
        const iframe = document.createElement('iframe');
        iframe.id = 'waypoint-universe-bridge';
        iframe.src = 'https://be-origo.com/waypoint_universe/';
        iframe.style.cssText = 'position:absolute;width:0;height:0;border:0;visibility:hidden;';
        document.body.appendChild(iframe);

        console.log('üì° Universe iframe created: https://be-origo.com/waypoint_universe/');

        // Initialize waypoint universe integration when iframe loads
        if (typeof WaypointUniverseIntegration !== 'undefined') {
          iframe.onload = function () {
            console.log('üåâ Waypoint Universe iframe loaded and ready');
          };
        }
      } else {
        console.log('üè† Localhost detected - Waypoint Universe sharing disabled (use localhost:9847/waypoint-universe for local testing)');
      }
    })();
  </script>



  <script>
    // ============================================================================
    // JAVASCRIPT: Spread Control Logic
    // ============================================================================

    // Preset configurations
    const SPREAD_PRESETS = {
      tight: {
        spreadPower: 0.85,
        maxRadius: 400,
        angleVariation: 0.2,
        name: 'Tight',
        description: 'Emphasizes semantic relationships - similar items cluster closely'
      },
      balanced: {
        spreadPower: 0.6,
        maxRadius: 600,
        angleVariation: 0.3,
        name: 'Balanced',
        description: 'Good balance between relationships and visual clarity'
      },
      spread: {
        spreadPower: 0.45,
        maxRadius: 700,
        angleVariation: 0.4,
        name: 'Spread Out',
        description: 'More visual separation - easier to see individual photos'
      },
      maximum: {
        spreadPower: 0.3,
        maxRadius: 850,
        angleVariation: 0.5,
        name: 'Maximum',
        description: 'Maximum spread - uses full canvas for dramatic showcase'
      }
    };

    // Current spread settings (starts with balanced)
    let currentSpreadSettings = SPREAD_PRESETS.balanced;

    // Initialize preset buttons
    document.querySelectorAll('.preset-btn').forEach(btn => {
      btn.addEventListener('click', function () {
        // Remove active class from all
        document.querySelectorAll('.preset-btn').forEach(b => {
          b.classList.remove('active');
          b.style.borderColor = '#e5e7eb';
          b.style.background = 'white';
        });

        // Add active to clicked
        this.classList.add('active');
        this.style.borderColor = '#6366f1';
        this.style.background = '#eef2ff';

        // Update settings
        const presetName = this.dataset.spread;
        currentSpreadSettings = SPREAD_PRESETS[presetName];

        // Update UI
        document.getElementById('currentStyle').textContent = currentSpreadSettings.name;
        document.getElementById('styleDescription').textContent = currentSpreadSettings.description;

        // Update slider to match
        document.getElementById('spreadSlider').value = currentSpreadSettings.spreadPower;
        document.getElementById('spreadValue').textContent = currentSpreadSettings.spreadPower.toFixed(2);

        // Save to gallery data
        saveSpreadSettings();

        // Re-render gallery with new settings
        if (typeof renderGallery === 'function') {
          renderGallery();
        }
      });
    });

    // Initialize slider
    const slider = document.getElementById('spreadSlider');
    const sliderValue = document.getElementById('spreadValue');

    slider.addEventListener('input', function () {
      const value = parseFloat(this.value);
      sliderValue.textContent = value.toFixed(2);

      // Update settings with custom values
      currentSpreadSettings = {
        spreadPower: value,
        maxRadius: 400 + (1 - value) * 450, // Inverse: lower power = wider radius
        angleVariation: 0.2 + (1 - value) * 0.3,
        name: 'Custom',
        description: 'Custom spread setting'
      };

      // Remove active from presets
      document.querySelectorAll('.preset-btn').forEach(b => {
        b.classList.remove('active');
        b.style.borderColor = '#e5e7eb';
        b.style.background = 'white';
      });

      document.getElementById('currentStyle').textContent = 'Custom';
      document.getElementById('styleDescription').textContent = `Custom spread (${value.toFixed(2)}) - adjust to your preference`;

      saveSpreadSettings();

      // Re-render gallery
      if (typeof renderGallery === 'function') {
        renderGallery();
      }
    });

    // Save settings to gallery JSON
    function saveSpreadSettings() {
      // This should integrate with your gallery save function
      // For now, just store in a variable
      if (typeof galleryData !== 'undefined') {
        galleryData.spatialSettings = {
          spreadPower: currentSpreadSettings.spreadPower,
          maxRadius: currentSpreadSettings.maxRadius,
          angleVariation: currentSpreadSettings.angleVariation,
          preset: currentSpreadSettings.name
        };

        // Trigger save to backend/file
        if (typeof saveGalleryData === 'function') {
          saveGalleryData();
        }
      }
    }

    // Load settings from gallery JSON on page load
    function loadSpreadSettings() {
      if (typeof galleryData !== 'undefined' && galleryData.spatialSettings) {
        currentSpreadSettings = galleryData.spatialSettings;

        // Update UI to reflect loaded settings
        const presetName = currentSpreadSettings.preset;
        if (presetName && SPREAD_PRESETS[presetName.toLowerCase()]) {
          const btn = document.querySelector(`[data-spread="${presetName.toLowerCase()}"]`);
          if (btn) btn.click();
        }
      }
    }

    // Call on page load
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', loadSpreadSettings);
    } else {
      loadSpreadSettings();
    }

    // ============================================================================
    // CREATOR BRIDGE TOGGLE
    // ============================================================================

    // Initialize creator bridge toggle
    document.addEventListener('DOMContentLoaded', () => {
      // Settings tabs toggle
      const settingsTabs = document.querySelectorAll('.settings-tab');
      const settingsPanels = document.querySelectorAll('.settings-panel');
      const panelCloseButtons = document.querySelectorAll('.panel-close');

      settingsTabs.forEach(tab => {
        tab.addEventListener('click', () => {
          const panelName = tab.dataset.panel;
          const panel = document.getElementById(`${panelName}-panel`);

          // Close all panels
          settingsPanels.forEach(p => p.style.display = 'none');
          settingsTabs.forEach(t => t.classList.remove('active'));

          // Open clicked panel
          if (panel) {
            panel.style.display = 'block';
            tab.classList.add('active');
          }
        });
      });

      // Close button handlers
      panelCloseButtons.forEach(btn => {
        btn.addEventListener('click', () => {
          const panelName = btn.dataset.panel;
          const panel = document.getElementById(`${panelName}-panel`);
          if (panel) {
            panel.style.display = 'none';
          }
          settingsTabs.forEach(t => t.classList.remove('active'));
        });
      });
    });

    // ============================================================================
    // MODIFIED calculatePositions() - Uses currentSpreadSettings
    // ============================================================================

    function calculatePositions(centerX, centerY) {
      const positions = {};
      positions[centerPhotoIndex] = { x: centerX, y: centerY };

      const others = allPhotos
        .map((p, idx) => ({ idx, commonality: commonalityMatrix[centerPhotoIndex][idx] }))
        .filter(p => p.idx !== centerPhotoIndex)
        .sort((a, b) => b.commonality - a.commonality);

      // üé® NEW: Use user-defined spread settings instead of auto-detection
      const { spreadPower, maxRadius, angleVariation } = currentSpreadSettings;

      console.log(`üé® Using ${currentSpreadSettings.name} layout (power=${spreadPower}, radius=${maxRadius})`);

      others.forEach((item, i) => {
        const commonality = item.commonality;
        const distance = 1 - commonality;

        // Apply user's chosen spread power
        const amplifiedDistance = Math.pow(distance, spreadPower);

        // Use user's chosen max radius
        const radialDistance = 200 + amplifiedDistance * maxRadius;

        const totalOthers = others.length;
        const usableAngleRange = Math.PI * (300 / 180);
        const startAngle = Math.PI * (30 / 180);
        const angleStep = usableAngleRange / totalOthers;
        const baseAngle = startAngle + (i * angleStep);

        // Use user's chosen angle variation
        const angleOffset = (Math.random() - 0.5) * angleVariation;
        const finalAngle = baseAngle + angleOffset;

        const horizontalScale = 1.3;
        const verticalScale = 0.85;

        const x = centerX + Math.cos(finalAngle) * radialDistance * horizontalScale;
        const y = centerY + Math.sin(finalAngle) * radialDistance * verticalScale;

        positions[item.idx] = { x, y };
      });

      return positions;
    }

  </script>


</body>

</html>
